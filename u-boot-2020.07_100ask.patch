diff -urN u-boot-2020.07/arch/arm/config.mk u-boot_2020.07_100ask/arch/arm/config.mk
--- u-boot-2020.07/arch/arm/config.mk	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/config.mk	2020-08-03 18:15:02.775102203 +0800
@@ -122,7 +122,7 @@
 
 ifneq ($(CONFIG_SPL_BUILD),y)
 # Check that only R_ARM_RELATIVE relocations are generated.
-ALL-y += checkarmreloc
+#ALL-y += checkarmreloc
 # The movt / movw can hardcode 16 bit parts of the addresses in the
 # instruction. Relocation is not supported for that case, so disable
 # such usage by requiring word relocations.
diff -urN u-boot-2020.07/arch/arm/cpu/arm920t/Makefile u-boot_2020.07_100ask/arch/arm/cpu/arm920t/Makefile
--- u-boot-2020.07/arch/arm/cpu/arm920t/Makefile	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/cpu/arm920t/Makefile	2020-08-03 18:15:02.775102203 +0800
@@ -9,6 +9,7 @@
 
 obj-$(CONFIG_EP93XX) += ep93xx/
 obj-$(CONFIG_IMX) += imx/
+obj-$(CONFIG_S3C24X0) += s3c24x0/
 
 # some files can only build in ARM mode
 
diff -urN u-boot-2020.07/arch/arm/cpu/arm920t/s3c24x0/cpu_info.c u-boot_2020.07_100ask/arch/arm/cpu/arm920t/s3c24x0/cpu_info.c
--- u-boot-2020.07/arch/arm/cpu/arm920t/s3c24x0/cpu_info.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/cpu/arm920t/s3c24x0/cpu_info.c	2020-08-03 18:15:02.775102203 +0800
@@ -0,0 +1,42 @@
+/*
+ * (C) Copyright 2010
+ * David Mueller <d.mueller@elsoft.ch>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch-s3c24x0/s3c24x0_cpu.h>
+
+typedef ulong (*getfreq)(void);
+
+extern ulong get_FCLK(void);
+extern ulong get_HCLK(void);
+extern ulong get_PCLK(void);
+
+static const getfreq freq_f[] = {
+	get_FCLK,
+	get_HCLK,
+	get_PCLK,
+};
+
+static const char freq_c[] = { 'F', 'H', 'P' };
+
+int print_cpuinfo(void)
+{
+	int i;
+	char buf[32];
+/* the S3C2400 seems to be lacking a CHIP ID register */
+#ifndef CONFIG_S3C2400
+	ulong cpuid;
+	struct s3c24x0_gpio * const gpio = s3c24x0_get_base_gpio();
+
+	cpuid = readl(&gpio->gstatus1);
+	printf("CPUID: %8lX\n", cpuid);
+#endif
+	for (i = 0; i < ARRAY_SIZE(freq_f); i++)
+		printf("%cCLK: %8s MHz\n", freq_c[i], strmhz(buf, freq_f[i]()));
+
+	return 0;
+}
diff -urN u-boot-2020.07/arch/arm/cpu/arm920t/s3c24x0/interrupts.c u-boot_2020.07_100ask/arch/arm/cpu/arm920t/s3c24x0/interrupts.c
--- u-boot-2020.07/arch/arm/cpu/arm920t/s3c24x0/interrupts.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/cpu/arm920t/s3c24x0/interrupts.c	2020-08-03 18:15:02.775102203 +0800
@@ -0,0 +1,26 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+
+#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/proc-armv/ptrace.h>
+
+void do_irq (struct pt_regs *pt_regs)
+{
+	struct s3c24x0_interrupt *irq = s3c24x0_get_base_interrupt();
+	u_int32_t intpnd = readl(&irq->INTPND);
+
+}
diff -urN u-boot-2020.07/arch/arm/cpu/arm920t/s3c24x0/Makefile u-boot_2020.07_100ask/arch/arm/cpu/arm920t/s3c24x0/Makefile
--- u-boot-2020.07/arch/arm/cpu/arm920t/s3c24x0/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/cpu/arm920t/s3c24x0/Makefile	2020-08-03 18:15:02.775102203 +0800
@@ -0,0 +1,11 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-$(CONFIG_USE_IRQ) += interrupts.o
+obj-$(CONFIG_DISPLAY_CPUINFO)	+= cpu_info.o
+obj-y	+= speed.o
+obj-y	+= timer.o
diff -urN u-boot-2020.07/arch/arm/cpu/arm920t/s3c24x0/speed.c u-boot_2020.07_100ask/arch/arm/cpu/arm920t/s3c24x0/speed.c
--- u-boot-2020.07/arch/arm/cpu/arm920t/s3c24x0/speed.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/cpu/arm920t/s3c24x0/speed.c	2020-08-03 18:15:02.775102203 +0800
@@ -0,0 +1,104 @@
+/*
+ * (C) Copyright 2001-2004
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, d.mueller@elsoft.ch
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/* This code should work for both the S3C2400 and the S3C2410
+ * as they seem to have the same PLL and clock machinery inside.
+ * The different address mapping is handled by the s3c24xx.h files below.
+ */
+
+#include <common.h>
+#ifdef CONFIG_S3C24X0
+
+#include <asm/io.h>
+#include <asm/arch/s3c24x0_cpu.h>
+
+#define MPLL 0
+#define UPLL 1
+
+extern void hang(void);
+
+/* ------------------------------------------------------------------------- */
+/* NOTE: This describes the proper use of this file.
+ *
+ * CONFIG_SYS_CLK_FREQ should be defined as the input frequency of the PLL.
+ *
+ * get_FCLK(), get_HCLK(), get_PCLK() and get_UCLK() return the clock of
+ * the specified bus in HZ.
+ */
+/* ------------------------------------------------------------------------- */
+
+static ulong get_PLLCLK(int pllreg)
+{
+	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
+	ulong r, m, p, s;
+
+	if (pllreg == MPLL)
+		r = readl(&clk_power->mpllcon);
+	else if (pllreg == UPLL)
+		r = readl(&clk_power->upllcon);
+	else
+		hang();
+
+	m = ((r & 0xFF000) >> 12) + 8;
+	p = ((r & 0x003F0) >> 4) + 2;
+	s = r & 0x3;
+
+#if defined(CONFIG_S3C2440)
+	if (pllreg == MPLL)
+		return 2 * m * (CONFIG_SYS_CLK_FREQ / (p << s));
+#endif
+	return (CONFIG_SYS_CLK_FREQ * m) / (p << s);
+
+}
+
+/* return FCLK frequency */
+ulong get_FCLK(void)
+{
+	return get_PLLCLK(MPLL);
+}
+
+/* return HCLK frequency */
+ulong get_HCLK(void)
+{
+	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
+#ifdef CONFIG_S3C2440
+	switch (readl(&clk_power->clkdivn) & 0x6) {
+	default:
+	case 0:
+		return get_FCLK();
+	case 2:
+		return get_FCLK() / 2;
+	case 4:
+		return (readl(&clk_power->camdivn) & (1 << 9)) ?
+			get_FCLK() / 8 : get_FCLK() / 4;
+	case 6:
+		return (readl(&clk_power->camdivn) & (1 << 8)) ?
+			get_FCLK() / 6 : get_FCLK() / 3;
+	}
+#else
+	return (readl(&clk_power->clkdivn) & 2) ? get_FCLK() / 2 : get_FCLK();
+#endif
+}
+
+/* return PCLK frequency */
+ulong get_PCLK(void)
+{
+	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
+
+	return (readl(&clk_power->clkdivn) & 1) ? get_HCLK() / 2 : get_HCLK();
+}
+
+/* return UCLK frequency */
+ulong get_UCLK(void)
+{
+	return get_PLLCLK(UPLL);
+}
+
+#endif /* CONFIG_S3C24X0 */
diff -urN u-boot-2020.07/arch/arm/cpu/arm920t/s3c24x0/timer.c u-boot_2020.07_100ask/arch/arm/cpu/arm920t/s3c24x0/timer.c
--- u-boot-2020.07/arch/arm/cpu/arm920t/s3c24x0/timer.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/cpu/arm920t/s3c24x0/timer.c	2020-08-03 18:15:02.775102203 +0800
@@ -0,0 +1,162 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#ifdef CONFIG_S3C24X0
+
+#include <asm/io.h>
+#include <asm/arch/s3c24x0_cpu.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern ulong get_PCLK(void);
+
+int timer_init(void)
+{
+	struct s3c24x0_timers *timers = s3c24x0_get_base_timers();
+	ulong tmr;
+
+	/* use PWM Timer 4 because it has no output */
+	/* prescaler for Timer 4 is 16 */
+	writel(0x0f00, &timers->tcfg0);
+	if (gd->arch.tbu == 0) {
+		/*
+		 * for 10 ms clock period @ PCLK with 4 bit divider = 1/2
+		 * (default) and prescaler = 16. Should be 10390
+		 * @33.25MHz and 15625 @ 50 MHz
+		 */
+		gd->arch.tbu = get_PCLK() / (2 * 16 * 100);
+		gd->arch.timer_rate_hz = get_PCLK() / (2 * 16);
+	}
+	/* load value for 10 ms timeout */
+	writel(gd->arch.tbu, &timers->tcntb4);
+	/* auto load, manual update of timer 4 */
+	tmr = (readl(&timers->tcon) & ~0x0700000) | 0x0600000;
+	writel(tmr, &timers->tcon);
+	/* auto load, start timer 4 */
+	tmr = (tmr & ~0x0700000) | 0x0500000;
+	writel(tmr, &timers->tcon);
+	gd->arch.lastinc = 0;
+	gd->arch.tbl = 0;
+
+	return 0;
+}
+
+void __udelay (unsigned long usec)
+{
+	ulong tmo;
+	ulong start = get_ticks();
+
+	tmo = usec / 1000;
+	tmo *= (gd->arch.tbu * 100);
+	tmo /= 1000;
+
+	while ((ulong) (get_ticks() - start) < tmo)
+		/*NOP*/;
+}
+
+ulong get_timer_masked(void)
+{
+	ulong tmr = get_ticks();
+
+	return tmr / (gd->arch.timer_rate_hz / CONFIG_SYS_HZ);
+}
+
+/*
+ * timer without interrupts
+ */
+ulong get_timer(ulong base)
+{
+	return get_timer_masked() - base;
+}
+
+void udelay_masked(unsigned long usec)
+{
+	ulong tmo;
+	ulong endtime;
+	signed long diff;
+
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= (gd->arch.tbu * 100);
+		tmo /= 1000;
+	} else {
+		tmo = usec * (gd->arch.tbu * 100);
+		tmo /= (1000 * 1000);
+	}
+
+	endtime = get_ticks() + tmo;
+
+	do {
+		ulong now = get_ticks();
+		diff = endtime - now;
+	} while (diff >= 0);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	struct s3c24x0_timers *timers = s3c24x0_get_base_timers();
+	ulong now = readl(&timers->tcnto4) & 0xffff;
+
+	if (gd->arch.lastinc >= now) {
+		/* normal mode */
+		gd->arch.tbl += gd->arch.lastinc - now;
+	} else {
+		/* we have an overflow ... */
+		gd->arch.tbl += gd->arch.lastinc + gd->arch.tbu - now;
+	}
+	gd->arch.lastinc = now;
+
+	return gd->arch.tbl;
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk(void)
+{
+	return CONFIG_SYS_HZ;
+}
+
+/*
+ * reset the cpu by setting up the watchdog timer and let him time out
+ */
+void reset_cpu(ulong ignored)
+{
+	struct s3c24x0_watchdog *watchdog;
+
+	watchdog = s3c24x0_get_base_watchdog();
+
+	/* Disable watchdog */
+	writel(0x0000, &watchdog->wtcon);
+
+	/* Initialize watchdog timer count register */
+	writel(0x0001, &watchdog->wtcnt);
+
+	/* Enable watchdog timer; assert reset at timer timeout */
+	writel(0x0021, &watchdog->wtcon);
+
+	while (1)
+		/* loop forever and wait for reset to happen */;
+
+	/*NOTREACHED*/
+}
+
+#endif /* CONFIG_S3C24X0 */
diff -urN u-boot-2020.07/arch/arm/cpu/arm920t/start.S u-boot_2020.07_100ask/arch/arm/cpu/arm920t/start.S
--- u-boot-2020.07/arch/arm/cpu/arm920t/start.S	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/cpu/arm920t/start.S	2020-08-03 18:15:02.775102203 +0800
@@ -49,6 +49,35 @@
 	bne	copyex
 #endif
 
+#ifdef CONFIG_S3C24X0
+/* turn off the watchdog */
+#  define pWTCON        0x53000000
+#  define INTMSK        0x4A000008      /* Interrupt-Controller base addresses */
+#  define INTSUBMSK     0x4A00001C
+#  define CLKDIVN       0x4C000014      /* clock divisor register */
+
+	ldr 	r0, =pWTCON
+	mov 	r1, #0x0
+	str 	r1, [r0]
+
+	/*
+	 * mask all IRQs by setting all bits in the INTMR - default
+	 */
+	mov 	r1, #0xffffffff
+	ldr 	r0, =INTMSK
+	str 	r1, [r0]
+# if defined(CONFIG_S3C2410)
+	ldr 	r1, =0x3ff
+	ldr 	r0, =INTSUBMSK
+	str 	r1, [r0]
+# endif
+
+	/* default FCLK is 120 MHz ! */
+	ldr 	r0, =CLKDIVN
+	mov 	r1, #5	/* FCLK:HCLK:PCLK=1:4:8 DaQui modified */
+	str 	r1, [r0]
+#endif  /* CONFIG_S3C24X0 */
+
 	/*
 	 * we do sys-critical inits only at reboot,
 	 * not when booting from ram!
diff -urN u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/gpio.h u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/gpio.h
--- u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/gpio.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/gpio.h	2020-08-03 18:15:02.807102497 +0800
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2012.
+ *
+ * Gabriel Huau <contact@huau-gabriel.fr>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _S3C24X0_GPIO_H_
+#define _S3C24X0_GPIO_H_
+
+enum s3c2440_gpio {
+	GPA0,
+	GPA1,
+	GPA2,
+	GPA3,
+	GPA4,
+	GPA5,
+	GPA6,
+	GPA7,
+	GPA8,
+	GPA9,
+	GPA10,
+	GPA11,
+	GPA12,
+	GPA13,
+	GPA14,
+	GPA15,
+	GPA16,
+	GPA17,
+	GPA18,
+	GPA19,
+	GPA20,
+	GPA21,
+	GPA22,
+	GPA23,
+	GPA24,
+
+	GPB0 = 32,
+	GPB1,
+	GPB2,
+	GPB3,
+	GPB4,
+	GPB5,
+	GPB6,
+	GPB7,
+	GPB8,
+	GPB9,
+	GPB10,
+
+	GPC0 = 64,
+	GPC1,
+	GPC2,
+	GPC3,
+	GPC4,
+	GPC5,
+	GPC6,
+	GPC7,
+	GPC8,
+	GPC9,
+	GPC10,
+	GPC11,
+	GPC12,
+	GPC13,
+	GPC14,
+	GPC15,
+
+	GPD0 = 96,
+	GPD1,
+	GPD2,
+	GPD3,
+	GPD4,
+	GPD5,
+	GPD6,
+	GPD7,
+	GPD8,
+	GPD9,
+	GPD10,
+	GPD11,
+	GPD12,
+	GPD13,
+	GPD14,
+	GPD15,
+
+	GPE0 = 128,
+	GPE1,
+	GPE2,
+	GPE3,
+	GPE4,
+	GPE5,
+	GPE6,
+	GPE7,
+	GPE8,
+	GPE9,
+	GPE10,
+	GPE11,
+	GPE12,
+	GPE13,
+	GPE14,
+	GPE15,
+
+	GPF0 = 160,
+	GPF1,
+	GPF2,
+	GPF3,
+	GPF4,
+	GPF5,
+	GPF6,
+	GPF7,
+
+	GPG0 = 192,
+	GPG1,
+	GPG2,
+	GPG3,
+	GPG4,
+	GPG5,
+	GPG6,
+	GPG7,
+	GPG8,
+	GPG9,
+	GPG10,
+	GPG11,
+	GPG12,
+	GPG13,
+	GPG14,
+	GPG15,
+
+	GPH0 = 224,
+	GPH1,
+	GPH2,
+	GPH3,
+	GPH4,
+	GPH5,
+	GPH6,
+	GPH7,
+	GPH8,
+	GPH9,
+	GPH10,
+
+	GPJ0 = 256,
+	GPJ1,
+	GPJ2,
+	GPJ3,
+	GPJ4,
+	GPJ5,
+	GPJ6,
+	GPJ7,
+	GPJ8,
+	GPJ9,
+	GPJ10,
+	GPJ11,
+	GPJ12,
+};
+
+#endif
diff -urN u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/iomux.h u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/iomux.h
--- u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/iomux.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/iomux.h	2020-08-03 18:15:02.807102497 +0800
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) 2012
+ *
+ * Gabriel Huau <contact@huau-gabriel.fr>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _S3C24X0_IOMUX_H_
+#define _S3C24X0_IOMUX_H_
+
+enum s3c2440_iomux_func {
+	/* PORT A */
+	IOMUXA_ADDR0	= 1,
+	IOMUXA_ADDR16	= (1 << 1),
+	IOMUXA_ADDR17	= (1 << 2),
+	IOMUXA_ADDR18	= (1 << 3),
+	IOMUXA_ADDR19	= (1 << 4),
+	IOMUXA_ADDR20	= (1 << 5),
+	IOMUXA_ADDR21	= (1 << 6),
+	IOMUXA_ADDR22	= (1 << 7),
+	IOMUXA_ADDR23	= (1 << 8),
+	IOMUXA_ADDR24	= (1 << 9),
+	IOMUXA_ADDR25	= (1 << 10),
+	IOMUXA_ADDR26	= (1 << 11),
+	IOMUXA_nGCS1	= (1 << 12),
+	IOMUXA_nGCS2	= (1 << 13),
+	IOMUXA_nGCS3	= (1 << 14),
+	IOMUXA_nGCS4	= (1 << 15),
+	IOMUXA_nGCS5	= (1 << 16),
+	IOMUXA_CLE	= (1 << 17),
+	IOMUXA_ALE	= (1 << 18),
+	IOMUXA_nFWE	= (1 << 19),
+	IOMUXA_nFRE	= (1 << 20),
+	IOMUXA_nRSTOUT	= (1 << 21),
+	IOMUXA_nFCE		= (1 << 22),
+
+	/* PORT B */
+	IOMUXB_nXDREQ0	= (2 << 20),
+	IOMUXB_nXDACK0	= (2 << 18),
+	IOMUXB_nXDREQ1	= (2 << 16),
+	IOMUXB_nXDACK1	= (2 << 14),
+	IOMUXB_nXBREQ	= (2 << 12),
+	IOMUXB_nXBACK	= (2 << 10),
+	IOMUXB_TCLK0	= (2 << 8),
+	IOMUXB_TOUT3	= (2 << 6),
+	IOMUXB_TOUT2	= (2 << 4),
+	IOMUXB_TOUT1	= (2 << 2),
+	IOMUXB_TOUT0	= 2,
+
+	/* PORT C */
+	IOMUXC_VS7	= (2 << 30),
+	IOMUXC_VS6	= (2 << 28),
+	IOMUXC_VS5	= (2 << 26),
+	IOMUXC_VS4	= (2 << 24),
+	IOMUXC_VS3	= (2 << 22),
+	IOMUXC_VS2	= (2 << 20),
+	IOMUXC_VS1	= (2 << 18),
+	IOMUXC_VS0	= (2 << 16),
+	IOMUXC_LCD_LPCREVB	= (2 << 14),
+	IOMUXC_LCD_LPCREV	= (2 << 12),
+	IOMUXC_LCD_LPCOE	= (2 << 10),
+	IOMUXC_VM		= (2 << 8),
+	IOMUXC_VFRAME	= (2 << 6),
+	IOMUXC_VLINE	= (2 << 4),
+	IOMUXC_VCLK		= (2 << 2),
+	IOMUXC_LEND		= 2,
+	IOMUXC_I2SSDI	= (3 << 8),
+
+	/* PORT D */
+	IOMUXD_VS23	= (2 << 30),
+	IOMUXD_VS22	= (2 << 28),
+	IOMUXD_VS21	= (2 << 26),
+	IOMUXD_VS20	= (2 << 24),
+	IOMUXD_VS19	= (2 << 22),
+	IOMUXD_VS18	= (2 << 20),
+	IOMUXD_VS17	= (2 << 18),
+	IOMUXD_VS16	= (2 << 16),
+	IOMUXD_VS15	= (2 << 14),
+	IOMUXD_VS14	= (2 << 12),
+	IOMUXD_VS13	= (2 << 10),
+	IOMUXD_VS12	= (2 << 8),
+	IOMUXD_VS11	= (2 << 6),
+	IOMUXD_VS10	= (2 << 4),
+	IOMUXD_VS9	= (2 << 2),
+	IOMUXD_VS8	= 2,
+	IOMUXD_nSS0	= (3 << 30),
+	IOMUXD_nSS1	= (3 << 28),
+	IOMUXD_SPICLK1	= (3 << 20),
+	IOMUXD_SPIMOSI1	= (3 << 18),
+	IOMUXD_SPIMISO1	= (3 << 16),
+
+	/* PORT E */
+	IOMUXE_IICSDA	= (2 << 30),
+	IOMUXE_IICSCL	= (2 << 28),
+	IOMUXE_SPICLK0	= (2 << 26),
+	IOMUXE_SPIMOSI0	= (2 << 24),
+	IOMUXE_SPIMISO0	= (2 << 22),
+	IOMUXE_SDDAT3	= (2 << 20),
+	IOMUXE_SDDAT2	= (2 << 18),
+	IOMUXE_SDDAT1	= (2 << 16),
+	IOMUXE_SDDAT0	= (2 << 14),
+	IOMUXE_SDCMD	= (2 << 12),
+	IOMUXE_SDCLK	= (2 << 10),
+	IOMUXE_I2SDO	= (2 << 8),
+	IOMUXE_I2SDI	= (2 << 6),
+	IOMUXE_CDCLK	= (2 << 4),
+	IOMUXE_I2SSCLK	= (2 << 2),
+	IOMUXE_I2SLRCK	= 2,
+	IOMUXE_AC_SDATA_OUT	= (3 << 8),
+	IOMUXE_AC_SDATA_IN	= (3 << 6),
+	IOMUXE_AC_nRESET	= (3 << 4),
+	IOMUXE_AC_BIT_CLK	= (3 << 2),
+	IOMUXE_AC_SYNC		= 3,
+
+	/* PORT F */
+	IOMUXF_EINT7	= (2 << 14),
+	IOMUXF_EINT6	= (2 << 12),
+	IOMUXF_EINT5	= (2 << 10),
+	IOMUXF_EINT4	= (2 << 8),
+	IOMUXF_EINT3	= (2 << 6),
+	IOMUXF_EINT2	= (2 << 4),
+	IOMUXF_EINT1	= (2 << 2),
+	IOMUXF_EINT0	= 2,
+
+	/* PORT G */
+	IOMUXG_EINT23	= (2 << 30),
+	IOMUXG_EINT22	= (2 << 28),
+	IOMUXG_EINT21	= (2 << 26),
+	IOMUXG_EINT20	= (2 << 24),
+	IOMUXG_EINT19	= (2 << 22),
+	IOMUXG_EINT18	= (2 << 20),
+	IOMUXG_EINT17	= (2 << 18),
+	IOMUXG_EINT16	= (2 << 16),
+	IOMUXG_EINT15	= (2 << 14),
+	IOMUXG_EINT14	= (2 << 12),
+	IOMUXG_EINT13	= (2 << 10),
+	IOMUXG_EINT12	= (2 << 8),
+	IOMUXG_EINT11	= (2 << 6),
+	IOMUXG_EINT10	= (2 << 4),
+	IOMUXG_EINT9	= (2 << 2),
+	IOMUXG_EINT8	= 2,
+	IOMUXG_TCLK1	= (3 << 22),
+	IOMUXG_nCTS1	= (3 << 20),
+	IOMUXG_nRTS1	= (3 << 18),
+	IOMUXG_SPICLK1	= (3 << 14),
+	IOMUXG_SPIMOSI1	= (3 << 12),
+	IOMUXG_SPIMISO1	= (3 << 10),
+	IOMUXG_LCD_PWRDN	= (3 << 8),
+	IOMUXG_nSS1			= (3 << 6),
+	IOMUXG_nSS0			= (3 << 4),
+
+	/* PORT H */
+	IOMUXH_CLKOUT1	= (2 << 20),
+	IOMUXH_CLKOUT0	= (2 << 18),
+	IOMUXH_UEXTCLK	= (2 << 16),
+	IOMUXH_RXD2		= (2 << 14),
+	IOMUXH_TXD2		= (2 << 12),
+	IOMUXH_RXD1		= (2 << 10),
+	IOMUXH_TXD1		= (2 << 8),
+	IOMUXH_RXD0		= (2 << 6),
+	IOMUXH_TXD0		= (2 << 4),
+	IOMUXH_nRTS0	= (2 << 2),
+	IOMUXH_nCTS0	= 2,
+	IOMUXH_nCTS1	= (3 << 14),
+	IOMUXH_nRTS1	= (3 << 12),
+
+	/* PORT J */
+	IOMUXJ_CAMRESET		= (2 << 24),
+	IOMUXJ_CAMCLKOUT	= (2 << 22),
+	IOMUXJ_CAMHREF		= (2 << 20),
+	IOMUXJ_CAMVSYNC		= (2 << 18),
+	IOMUXJ_CAMPCLK		= (2 << 16),
+	IOMUXJ_CAMDATA7		= (2 << 14),
+	IOMUXJ_CAMDATA6		= (2 << 12),
+	IOMUXJ_CAMDATA5		= (2 << 10),
+	IOMUXJ_CAMDATA4		= (2 << 8),
+	IOMUXJ_CAMDATA3		= (2 << 6),
+	IOMUXJ_CAMDATA2		= (2 << 4),
+	IOMUXJ_CAMDATA1		= (2 << 2),
+	IOMUXJ_CAMDATA0		= 2
+};
+
+#endif
diff -urN u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/memory.h u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/memory.h
--- u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/memory.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/memory.h	2020-08-03 18:15:02.811102533 +0800
@@ -0,0 +1,159 @@
+/*
+ * linux/include/asm-arm/arch-s3c2400/memory.h by garyj@denx.de
+ * based on
+ * linux/include/asm-arm/arch-sa1100/memory.h
+ *
+ * Copyright (c) 1999 Nicolas Pitre <nico@visuaide.com>
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+
+/*
+ * Task size: 3GB
+ */
+#define TASK_SIZE       (0xc0000000UL)
+#define TASK_SIZE_26	(0x04000000UL)
+
+/*
+ * This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+#define TASK_UNMAPPED_BASE (TASK_SIZE / 3)
+
+/*
+ * Page offset: 3GB
+ */
+#define PAGE_OFFSET     (0xc0000000UL)
+
+/*
+ * Physical DRAM offset is 0x0c000000 on the S3C2400
+ */
+#define PHYS_OFFSET	(0x0c000000UL)
+
+/* Modified for S3C2400, by chc, 20010509 */
+#define RAM_IN_BANK_0  32*1024*1024
+#define RAM_IN_BANK_1  0
+#define RAM_IN_BANK_2  0
+#define RAM_IN_BANK_3  0
+
+#define MEM_SIZE  (RAM_IN_BANK_0+RAM_IN_BANK_1+RAM_IN_BANK_2+RAM_IN_BANK_3)
+
+
+/* translation macros */
+#define __virt_to_phys__is_a_macro
+#define __phys_to_virt__is_a_macro
+
+#if (RAM_IN_BANK_1 + RAM_IN_BANK_2 + RAM_IN_BANK_3 == 0)
+
+#define __virt_to_phys(x) ( (x) - PAGE_OFFSET + 0x0c000000 )
+#define __phys_to_virt(x) ( (x) - 0x0c000000 + PAGE_OFFSET )
+
+#elif (RAM_IN_BANK_0 == RAM_IN_BANK_1) && \
+      (RAM_IN_BANK_2 + RAM_IN_BANK_3 == 0)
+
+/* Two identical banks */
+#define __virt_to_phys(x) \
+	  ( ((x) < PAGE_OFFSET+RAM_IN_BANK_0) ? \
+	    ((x) - PAGE_OFFSET + _DRAMBnk0) : \
+	    ((x) - PAGE_OFFSET - RAM_IN_BANK_0 + _DRAMBnk1) )
+#define __phys_to_virt(x) \
+	  ( ((x)&0x07ffffff) + \
+	    (((x)&0x08000000) ? PAGE_OFFSET+RAM_IN_BANK_0 : PAGE_OFFSET) )
+#else
+
+/* It's more efficient for all other cases to use the function call */
+#undef __virt_to_phys__is_a_macro
+#undef __phys_to_virt__is_a_macro
+extern unsigned long __virt_to_phys(unsigned long vpage);
+extern unsigned long __phys_to_virt(unsigned long ppage);
+
+#endif
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ *
+ * On the SA1100, bus addresses are equivalent to physical addresses.
+ */
+#define __virt_to_bus__is_a_macro
+#define __virt_to_bus(x)        __virt_to_phys(x)
+#define __bus_to_virt__is_a_macro
+#define __bus_to_virt(x)        __phys_to_virt(x)
+
+
+#ifdef CONFIG_DISCONTIGMEM
+#error "CONFIG_DISCONTIGMEM will not work on S3C2400"
+/*
+ * Because of the wide memory address space between physical RAM banks on the
+ * SA1100, it's much more convenient to use Linux's NUMA support to implement
+ * our memory map representation.  Assuming all memory nodes have equal access
+ * characteristics, we then have generic discontiguous memory support.
+ *
+ * Of course, all this isn't mandatory for SA1100 implementations with only
+ * one used memory bank.  For those, simply undefine CONFIG_DISCONTIGMEM.
+ *
+ * The nodes are matched with the physical memory bank addresses which are
+ * incidentally the same as virtual addresses.
+ *
+ *	node 0:  0xc0000000 - 0xc7ffffff
+ *	node 1:  0xc8000000 - 0xcfffffff
+ *	node 2:  0xd0000000 - 0xd7ffffff
+ *	node 3:  0xd8000000 - 0xdfffffff
+ */
+
+#define NR_NODES	4
+
+/*
+ * Given a kernel address, find the home node of the underlying memory.
+ */
+#define KVADDR_TO_NID(addr) \
+		(((unsigned long)(addr) - 0xc0000000) >> 27)
+
+/*
+ * Given a physical address, convert it to a node id.
+ */
+#define PHYS_TO_NID(addr) KVADDR_TO_NID(__phys_to_virt(addr))
+
+/*
+ * Given a kaddr, ADDR_TO_MAPBASE finds the owning node of the memory
+ * and returns the mem_map of that node.
+ */
+#define ADDR_TO_MAPBASE(kaddr) \
+			NODE_MEM_MAP(KVADDR_TO_NID((unsigned long)(kaddr)))
+
+/*
+ * Given a kaddr, LOCAL_MEM_MAP finds the owning node of the memory
+ * and returns the index corresponding to the appropriate page in the
+ * node's mem_map.
+ */
+#define LOCAL_MAP_NR(kvaddr) \
+	(((unsigned long)(kvaddr) & 0x07ffffff) >> PAGE_SHIFT)
+
+/*
+ * Given a kaddr, virt_to_page returns a pointer to the corresponding
+ * mem_map entry.
+ */
+#define virt_to_page(kaddr) \
+	(ADDR_TO_MAPBASE(kaddr) + LOCAL_MAP_NR(kaddr))
+
+/*
+ * VALID_PAGE returns a non-zero value if given page pointer is valid.
+ * This assumes all node's mem_maps are stored within the node they refer to.
+ */
+#define VALID_PAGE(page) \
+({ unsigned int node = KVADDR_TO_NID(page); \
+   ( (node < NR_NODES) && \
+     ((unsigned)((page) - NODE_MEM_MAP(node)) < NODE_DATA(node)->node_size) ); \
+})
+
+#else
+
+#define PHYS_TO_NID(addr)	(0)
+
+#endif
+#endif /* __ASM_ARCH_MEMORY_H */
diff -urN u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/s3c2400.h u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/s3c2400.h
--- u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/s3c2400.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/s3c2400.h	2020-08-03 18:15:02.811102533 +0800
@@ -0,0 +1,136 @@
+/*
+ * (C) Copyright 2003
+ * David MÃ¼ller ELSOFT AG Switzerland. d.mueller@elsoft.ch
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/************************************************
+ * NAME	    : s3c2400.h
+ * Version  : 31.3.2003
+ *
+ * Based on S3C2400X User's manual Rev 1.1
+ ************************************************/
+
+#ifndef __S3C2400_H__
+#define __S3C2400_H__
+
+#define S3C24X0_UART_CHANNELS	2
+#define S3C24X0_SPI_CHANNELS	1
+#define PALETTE			(0x14A00400)	/* SJS */
+
+enum s3c24x0_uarts_nr {
+	S3C24X0_UART0,
+	S3C24X0_UART1,
+};
+
+/*S3C2400 device base addresses */
+#define S3C24X0_MEMCTL_BASE		0x14000000
+#define S3C24X0_USB_HOST_BASE		0x14200000
+#define S3C24X0_INTERRUPT_BASE		0x14400000
+#define S3C24X0_DMA_BASE		0x14600000
+#define S3C24X0_CLOCK_POWER_BASE	0x14800000
+#define S3C24X0_LCD_BASE		0x14A00000
+#define S3C24X0_UART_BASE		0x15000000
+#define S3C24X0_TIMER_BASE		0x15100000
+#define S3C24X0_USB_DEVICE_BASE		0x15200140
+#define S3C24X0_WATCHDOG_BASE		0x15300000
+#define S3C24X0_I2C_BASE		0x15400000
+#define S3C24X0_I2S_BASE		0x15508000
+#define S3C24X0_GPIO_BASE		0x15600000
+#define S3C24X0_RTC_BASE		0x15700000
+#define S3C24X0_ADC_BASE		0x15800000
+#define S3C24X0_SPI_BASE		0x15900000
+#define S3C2400_MMC_BASE		0x15A00000
+
+/* include common stuff */
+#include <asm/arch/s3c24x0.h>
+
+
+static inline struct s3c24x0_memctl *s3c24x0_get_base_memctl(void)
+{
+	return (struct s3c24x0_memctl *)S3C24X0_MEMCTL_BASE;
+}
+
+static inline struct s3c24x0_usb_host *s3c24x0_get_base_usb_host(void)
+{
+	return (struct s3c24x0_usb_host *)S3C24X0_USB_HOST_BASE;
+}
+
+static inline struct s3c24x0_interrupt *s3c24x0_get_base_interrupt(void)
+{
+	return (struct s3c24x0_interrupt *)S3C24X0_INTERRUPT_BASE;
+}
+
+static inline struct s3c24x0_dmas *s3c24x0_get_base_dmas(void)
+{
+	return (struct s3c24x0_dmas *)S3C24X0_DMA_BASE;
+}
+
+static inline struct s3c24x0_clock_power *s3c24x0_get_base_clock_power(void)
+{
+	return (struct s3c24x0_clock_power *)S3C24X0_CLOCK_POWER_BASE;
+}
+
+static inline struct s3c24x0_lcd *s3c24x0_get_base_lcd(void)
+{
+	return (struct s3c24x0_lcd *)S3C24X0_LCD_BASE;
+}
+
+static inline struct s3c24x0_uart
+	*s3c24x0_get_base_uart(enum s3c24x0_uarts_nr n)
+{
+	return (struct s3c24x0_uart *)(S3C24X0_UART_BASE + (n * 0x4000));
+}
+
+static inline struct s3c24x0_timers *s3c24x0_get_base_timers(void)
+{
+	return (struct s3c24x0_timers *)S3C24X0_TIMER_BASE;
+}
+
+static inline struct s3c24x0_usb_device *s3c24x0_get_base_usb_device(void)
+{
+	return (struct s3c24x0_usb_device *)S3C24X0_USB_DEVICE_BASE;
+}
+
+static inline struct s3c24x0_watchdog *s3c24x0_get_base_watchdog(void)
+{
+	return (struct s3c24x0_watchdog *)S3C24X0_WATCHDOG_BASE;
+}
+
+static inline struct s3c24x0_i2c *s3c24x0_get_base_i2c(void)
+{
+	return (struct s3c24x0_i2c *)S3C24X0_I2C_BASE;
+}
+
+static inline struct s3c24x0_i2s *s3c24x0_get_base_i2s(void)
+{
+	return (struct s3c24x0_i2s *)S3C24X0_I2S_BASE;
+}
+
+static inline struct s3c24x0_gpio *s3c24x0_get_base_gpio(void)
+{
+	return (struct s3c24x0_gpio *)S3C24X0_GPIO_BASE;
+}
+
+static inline struct s3c24x0_rtc *s3c24x0_get_base_rtc(void)
+{
+	return (struct s3c24x0_rtc *)S3C24X0_RTC_BASE;
+}
+
+static inline struct s3c2400_adc *s3c2400_get_base_adc(void)
+{
+	return (struct s3c2400_adc *)S3C24X0_ADC_BASE;
+}
+
+static inline struct s3c24x0_spi *s3c24x0_get_base_spi(void)
+{
+	return (struct s3c24x0_spi *)S3C24X0_SPI_BASE;
+}
+
+static inline struct s3c2400_mmc *s3c2400_get_base_mmc(void)
+{
+	return (struct s3c2400_mmc *)S3C2400_MMC_BASE;
+}
+
+#endif /*__S3C2400_H__*/
diff -urN u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/s3c2410.h u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/s3c2410.h
--- u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/s3c2410.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/s3c2410.h	2020-08-03 18:15:02.811102533 +0800
@@ -0,0 +1,147 @@
+/*
+ * (C) Copyright 2003
+ * David MÃ¼ller ELSOFT AG Switzerland. d.mueller@elsoft.ch
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/************************************************
+ * NAME	    : s3c2410.h
+ * Version  : 31.3.2003
+ *
+ * Based on S3C2410X User's manual Rev 1.1
+ ************************************************/
+
+#ifndef __S3C2410_H__
+#define __S3C2410_H__
+
+#define S3C24X0_UART_CHANNELS	3
+#define S3C24X0_SPI_CHANNELS	2
+
+/* S3C2410 only supports 512 Byte HW ECC */
+#define S3C2410_ECCSIZE		512
+#define S3C2410_ECCBYTES	3
+
+enum s3c24x0_uarts_nr {
+	S3C24X0_UART0,
+	S3C24X0_UART1,
+	S3C24X0_UART2
+};
+
+/* S3C2410 device base addresses */
+#define S3C24X0_MEMCTL_BASE		0x48000000
+#define S3C24X0_USB_HOST_BASE		0x49000000
+#define S3C24X0_INTERRUPT_BASE		0x4A000000
+#define S3C24X0_DMA_BASE		0x4B000000
+#define S3C24X0_CLOCK_POWER_BASE	0x4C000000
+#define S3C24X0_LCD_BASE		0x4D000000
+#define S3C2410_NAND_BASE		0x4E000000
+#define S3C24X0_UART_BASE		0x50000000
+#define S3C24X0_TIMER_BASE		0x51000000
+#define S3C24X0_USB_DEVICE_BASE		0x52000140
+#define S3C24X0_WATCHDOG_BASE		0x53000000
+#define S3C24X0_I2C_BASE		0x54000000
+#define S3C24X0_I2S_BASE		0x55000000
+#define S3C24X0_GPIO_BASE		0x56000000
+#define S3C24X0_RTC_BASE		0x57000000
+#define S3C2410_ADC_BASE		0x58000000
+#define S3C24X0_SPI_BASE		0x59000000
+#define S3C2410_SDI_BASE		0x5A000000
+
+
+/* include common stuff */
+#include <asm/arch/s3c24x0.h>
+
+
+static inline struct s3c24x0_memctl *s3c24x0_get_base_memctl(void)
+{
+	return (struct s3c24x0_memctl *)S3C24X0_MEMCTL_BASE;
+}
+
+static inline struct s3c24x0_usb_host *s3c24x0_get_base_usb_host(void)
+{
+	return (struct s3c24x0_usb_host *)S3C24X0_USB_HOST_BASE;
+}
+
+static inline struct s3c24x0_interrupt *s3c24x0_get_base_interrupt(void)
+{
+	return (struct s3c24x0_interrupt *)S3C24X0_INTERRUPT_BASE;
+}
+
+static inline struct s3c24x0_dmas *s3c24x0_get_base_dmas(void)
+{
+	return (struct s3c24x0_dmas *)S3C24X0_DMA_BASE;
+}
+
+static inline struct s3c24x0_clock_power *s3c24x0_get_base_clock_power(void)
+{
+	return (struct s3c24x0_clock_power *)S3C24X0_CLOCK_POWER_BASE;
+}
+
+static inline struct s3c24x0_lcd *s3c24x0_get_base_lcd(void)
+{
+	return (struct s3c24x0_lcd *)S3C24X0_LCD_BASE;
+}
+
+static inline struct s3c24x0_nand *s3c24x0_get_base_nand(void)
+{
+	return (struct s3c24x0_nand *)S3C2410_NAND_BASE;
+}
+
+static inline struct s3c24x0_uart
+	*s3c24x0_get_base_uart(enum s3c24x0_uarts_nr n)
+{
+	return (struct s3c24x0_uart *)(S3C24X0_UART_BASE + (n * 0x4000));
+}
+
+static inline struct s3c24x0_timers *s3c24x0_get_base_timers(void)
+{
+	return (struct s3c24x0_timers *)S3C24X0_TIMER_BASE;
+}
+
+static inline struct s3c24x0_usb_device *s3c24x0_get_base_usb_device(void)
+{
+	return (struct s3c24x0_usb_device *)S3C24X0_USB_DEVICE_BASE;
+}
+
+static inline struct s3c24x0_watchdog *s3c24x0_get_base_watchdog(void)
+{
+	return (struct s3c24x0_watchdog *)S3C24X0_WATCHDOG_BASE;
+}
+
+static inline struct s3c24x0_i2c *s3c24x0_get_base_i2c(void)
+{
+	return (struct s3c24x0_i2c *)S3C24X0_I2C_BASE;
+}
+
+static inline struct s3c24x0_i2s *s3c24x0_get_base_i2s(void)
+{
+	return (struct s3c24x0_i2s *)S3C24X0_I2S_BASE;
+}
+
+static inline struct s3c24x0_gpio *s3c24x0_get_base_gpio(void)
+{
+	return (struct s3c24x0_gpio *)S3C24X0_GPIO_BASE;
+}
+
+static inline struct s3c24x0_rtc *s3c24x0_get_base_rtc(void)
+{
+	return (struct s3c24x0_rtc *)S3C24X0_RTC_BASE;
+}
+
+static inline struct s3c2410_adc *s3c2410_get_base_adc(void)
+{
+	return (struct s3c2410_adc *)S3C2410_ADC_BASE;
+}
+
+static inline struct s3c24x0_spi *s3c24x0_get_base_spi(void)
+{
+	return (struct s3c24x0_spi *)S3C24X0_SPI_BASE;
+}
+
+static inline struct s3c24x0_sdi *s3c24x0_get_base_sdi(void)
+{
+	return (struct s3c24x0_sdi *)S3C2410_SDI_BASE;
+}
+
+#endif /*__S3C2410_H__*/
diff -urN u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/s3c2440.h u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/s3c2440.h
--- u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/s3c2440.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/s3c2440.h	2020-08-03 18:15:02.811102533 +0800
@@ -0,0 +1,145 @@
+/*
+ * (C) Copyright 2003
+ * David Mueller ELSOFT AG Switzerland. d.mueller@elsoft.ch
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/************************************************
+ * NAME	    : s3c2440.h
+ * Version  : 31.3.2003
+ *
+ * Based on S3C2440 User's manual Rev x.x
+ ************************************************/
+
+#ifndef __S3C2440_H__
+#define __S3C2440_H__
+
+#define S3C24X0_UART_CHANNELS	3
+#define S3C24X0_SPI_CHANNELS	2
+
+/* S3C2440 only supports 512 Byte HW ECC */
+#define S3C2440_ECCSIZE		512
+#define S3C2440_ECCBYTES	3
+
+enum s3c24x0_uarts_nr {
+	S3C24X0_UART0,
+	S3C24X0_UART1,
+	S3C24X0_UART2
+};
+
+/* S3C2440 device base addresses */
+#define S3C24X0_MEMCTL_BASE		0x48000000
+#define S3C24X0_USB_HOST_BASE		0x49000000
+#define S3C24X0_INTERRUPT_BASE		0x4A000000
+#define S3C24X0_DMA_BASE		0x4B000000
+#define S3C24X0_CLOCK_POWER_BASE	0x4C000000
+#define S3C24X0_LCD_BASE		0x4D000000
+#define S3C2440_NAND_BASE		0x4E000000
+#define S3C24X0_UART_BASE		0x50000000
+#define S3C24X0_TIMER_BASE		0x51000000
+#define S3C24X0_USB_DEVICE_BASE		0x52000140
+#define S3C24X0_WATCHDOG_BASE		0x53000000
+#define S3C24X0_I2C_BASE		0x54000000
+#define S3C24X0_I2S_BASE		0x55000000
+#define S3C24X0_GPIO_BASE		0x56000000
+#define S3C24X0_RTC_BASE		0x57000000
+#define S3C2440_ADC_BASE		0x58000000
+#define S3C24X0_SPI_BASE		0x59000000
+#define S3C2440_SDI_BASE		0x5A000000
+
+/* include common stuff */
+#include <asm/arch/s3c24x0.h>
+
+static inline struct s3c24x0_memctl *s3c24x0_get_base_memctl(void)
+{
+	return (struct s3c24x0_memctl *)S3C24X0_MEMCTL_BASE;
+}
+
+static inline struct s3c24x0_usb_host *s3c24x0_get_base_usb_host(void)
+{
+	return (struct s3c24x0_usb_host *)S3C24X0_USB_HOST_BASE;
+}
+
+static inline struct s3c24x0_interrupt *s3c24x0_get_base_interrupt(void)
+{
+	return (struct s3c24x0_interrupt *)S3C24X0_INTERRUPT_BASE;
+}
+
+static inline struct s3c24x0_dmas *s3c24x0_get_base_dmas(void)
+{
+	return (struct s3c24x0_dmas *)S3C24X0_DMA_BASE;
+}
+
+static inline struct s3c24x0_clock_power *s3c24x0_get_base_clock_power(void)
+{
+	return (struct s3c24x0_clock_power *)S3C24X0_CLOCK_POWER_BASE;
+}
+
+static inline struct s3c24x0_lcd *s3c24x0_get_base_lcd(void)
+{
+	return (struct s3c24x0_lcd *)S3C24X0_LCD_BASE;
+}
+
+static inline struct s3c24x0_nand *s3c24x0_get_base_nand(void)
+{
+	return (struct s3c24x0_nand *)S3C2440_NAND_BASE;
+}
+
+static inline struct s3c24x0_uart
+	*s3c24x0_get_base_uart(enum s3c24x0_uarts_nr n)
+{
+	return (struct s3c24x0_uart *)(S3C24X0_UART_BASE + (n * 0x4000));
+}
+
+static inline struct s3c24x0_timers *s3c24x0_get_base_timers(void)
+{
+	return (struct s3c24x0_timers *)S3C24X0_TIMER_BASE;
+}
+
+static inline struct s3c24x0_usb_device *s3c24x0_get_base_usb_device(void)
+{
+	return (struct s3c24x0_usb_device *)S3C24X0_USB_DEVICE_BASE;
+}
+
+static inline struct s3c24x0_watchdog *s3c24x0_get_base_watchdog(void)
+{
+	return (struct s3c24x0_watchdog *)S3C24X0_WATCHDOG_BASE;
+}
+
+static inline struct s3c24x0_i2c *s3c24x0_get_base_i2c(void)
+{
+	return (struct s3c24x0_i2c *)S3C24X0_I2C_BASE;
+}
+
+static inline struct s3c24x0_i2s *s3c24x0_get_base_i2s(void)
+{
+	return (struct s3c24x0_i2s *)S3C24X0_I2S_BASE;
+}
+
+static inline struct s3c24x0_gpio *s3c24x0_get_base_gpio(void)
+{
+	return (struct s3c24x0_gpio *)S3C24X0_GPIO_BASE;
+}
+
+static inline struct s3c24x0_rtc *s3c24x0_get_base_rtc(void)
+{
+	return (struct s3c24x0_rtc *)S3C24X0_RTC_BASE;
+}
+
+static inline struct s3c2440_adc *s3c2440_get_base_adc(void)
+{
+	return (struct s3c2440_adc *)S3C2440_ADC_BASE;
+}
+
+static inline struct s3c24x0_spi *s3c24x0_get_base_spi(void)
+{
+	return (struct s3c24x0_spi *)S3C24X0_SPI_BASE;
+}
+
+static inline struct s3c24x0_sdi *s3c24x0_get_base_sdi(void)
+{
+	return (struct s3c24x0_sdi *)S3C2440_SDI_BASE;
+}
+
+#endif /*__S3C2440_H__*/
diff -urN u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/s3c24x0_cpu.h u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/s3c24x0_cpu.h
--- u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/s3c24x0_cpu.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/s3c24x0_cpu.h	2020-08-03 18:15:02.811102533 +0800
@@ -0,0 +1,16 @@
+/*
+ * (C) Copyright 2009
+ * Kevin Morfitt, Fearnside Systems Ltd, <kevin.morfitt@fearnside-systems.co.uk>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifdef CONFIG_S3C2400
+	#include <asm/arch/s3c2400.h>
+#elif defined CONFIG_S3C2410
+	#include <asm/arch/s3c2410.h>
+#elif defined CONFIG_S3C2440
+	#include <asm/arch/s3c2440.h>
+#else
+	#error Please define the s3c24x0 cpu type
+#endif
diff -urN u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/s3c24x0.h u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/s3c24x0.h
--- u-boot-2020.07/arch/arm/include/asm/arch-s3c24x0/s3c24x0.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/include/asm/arch-s3c24x0/s3c24x0.h	2020-08-03 18:15:02.811102533 +0800
@@ -0,0 +1,708 @@
+/*
+ * (C) Copyright 2003
+ * David MÃ¼ller ELSOFT AG Switzerland. d.mueller@elsoft.ch
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/************************************************
+ * NAME	    : s3c24x0.h
+ * Version  : 31.3.2003
+ *
+ * common stuff for SAMSUNG S3C24X0 SoC
+ ************************************************/
+
+#ifndef __S3C24X0_H__
+#define __S3C24X0_H__
+
+/* Memory controller (see manual chapter 5) */
+struct s3c24x0_memctl {
+	u32	bwscon;
+	u32	bankcon[8];
+	u32	refresh;
+	u32	banksize;
+	u32	mrsrb6;
+	u32	mrsrb7;
+};
+
+
+/* USB HOST (see manual chapter 12) */
+struct s3c24x0_usb_host {
+	u32	HcRevision;
+	u32	HcControl;
+	u32	HcCommonStatus;
+	u32	HcInterruptStatus;
+	u32	HcInterruptEnable;
+	u32	HcInterruptDisable;
+	u32	HcHCCA;
+	u32	HcPeriodCuttendED;
+	u32	HcControlHeadED;
+	u32	HcControlCurrentED;
+	u32	HcBulkHeadED;
+	u32	HcBuldCurrentED;
+	u32	HcDoneHead;
+	u32	HcRmInterval;
+	u32	HcFmRemaining;
+	u32	HcFmNumber;
+	u32	HcPeriodicStart;
+	u32	HcLSThreshold;
+	u32	HcRhDescriptorA;
+	u32	HcRhDescriptorB;
+	u32	HcRhStatus;
+	u32	HcRhPortStatus1;
+	u32	HcRhPortStatus2;
+};
+
+
+/* INTERRUPT (see manual chapter 14) */
+struct s3c24x0_interrupt {
+	u32	srcpnd;
+	u32	intmod;
+	u32	intmsk;
+	u32	priority;
+	u32	intpnd;
+	u32	intoffset;
+#if defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440)
+	u32	subsrcpnd;
+	u32	intsubmsk;
+#endif
+};
+
+
+/* DMAS (see manual chapter 8) */
+struct s3c24x0_dma {
+	u32	disrc;
+#if defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440)
+	u32	disrcc;
+#endif
+	u32	didst;
+#if defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440)
+	u32	didstc;
+#endif
+	u32	dcon;
+	u32	dstat;
+	u32	dcsrc;
+	u32	dcdst;
+	u32	dmasktrig;
+#if defined(CONFIG_S3C2400) || defined(CONFIG_S3C2410) \
+		|| defined(CONFIG_S3C2440)
+	u32	res[1];
+#endif
+};
+
+struct s3c24x0_dmas {
+	struct s3c24x0_dma	dma[4];
+};
+
+
+/* CLOCK & POWER MANAGEMENT (see S3C2400 manual chapter 6) */
+/*                          (see S3C2410 manual chapter 7) */
+struct s3c24x0_clock_power {
+	u32	locktime;
+	u32	mpllcon;
+	u32	upllcon;
+	u32	clkcon;
+	u32	clkslow;
+	u32	clkdivn;
+#if defined(CONFIG_S3C2440)
+	u32	camdivn;
+#endif
+};
+
+
+/* LCD CONTROLLER (see manual chapter 15) */
+struct s3c24x0_lcd {
+	u32	lcdcon1;
+	u32	lcdcon2;
+	u32	lcdcon3;
+	u32	lcdcon4;
+	u32	lcdcon5;
+	u32	lcdsaddr1;
+	u32	lcdsaddr2;
+	u32	lcdsaddr3;
+	u32	redlut;
+	u32	greenlut;
+	u32	bluelut;
+	u32	res[8];
+	u32	dithmode;
+	u32	tpal;
+#if defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440)
+	u32	lcdintpnd;
+	u32	lcdsrcpnd;
+	u32	lcdintmsk;
+	u32	lpcsel;
+#endif
+};
+
+
+/* NAND FLASH (see manual chapter 6) */
+struct s3c24x0_nand {
+	u32	nfconf;
+#ifndef CONFIG_S3C2410
+	u32	nfcont;
+#endif
+	u32	nfcmd;
+	u32	nfaddr;
+	u32	nfdata;
+#ifndef CONFIG_S3C2410
+	u32	nfeccd0;
+	u32	nfeccd1;
+	u32	nfeccd;
+#endif
+	u32	nfstat;
+#ifdef CONFIG_S3C2410
+	u32	nfecc;
+#else
+	u32	nfstat0;
+	u32	nfstat1;
+	u32	nfmecc0;
+	u32	nfmecc1;
+	u32	nfsecc;
+	u32	nfsblk;
+	u32	nfeblk;
+#endif
+};
+
+/* UART (see manual chapter 11) */
+struct s3c24x0_uart {
+	u32	ulcon;
+	u32	ucon;
+	u32	ufcon;
+	u32	umcon;
+	u32	utrstat;
+	u32	uerstat;
+	u32	ufstat;
+	u32	umstat;
+#ifdef __BIG_ENDIAN
+	u8	res1[3];
+	u8	utxh;
+	u8	res2[3];
+	u8	urxh;
+#else /* Little Endian */
+	u8	utxh;
+	u8	res1[3];
+	u8	urxh;
+	u8	res2[3];
+#endif
+	u32	ubrdiv;
+};
+
+
+/* PWM TIMER (see manual chapter 10) */
+struct s3c24x0_timer {
+	u32	tcntb;
+	u32	tcmpb;
+	u32	tcnto;
+};
+
+struct s3c24x0_timers {
+	u32	tcfg0;
+	u32	tcfg1;
+	u32	tcon;
+	struct s3c24x0_timer	ch[4];
+	u32	tcntb4;
+	u32	tcnto4;
+};
+
+
+/* USB DEVICE (see manual chapter 13) */
+struct s3c24x0_usb_dev_fifos {
+#ifdef __BIG_ENDIAN
+	u8	res[3];
+	u8	ep_fifo_reg;
+#else /*  little endian */
+	u8	ep_fifo_reg;
+	u8	res[3];
+#endif
+};
+
+struct s3c24x0_usb_dev_dmas {
+#ifdef __BIG_ENDIAN
+	u8	res1[3];
+	u8	ep_dma_con;
+	u8	res2[3];
+	u8	ep_dma_unit;
+	u8	res3[3];
+	u8	ep_dma_fifo;
+	u8	res4[3];
+	u8	ep_dma_ttc_l;
+	u8	res5[3];
+	u8	ep_dma_ttc_m;
+	u8	res6[3];
+	u8	ep_dma_ttc_h;
+#else /*  little endian */
+	u8	ep_dma_con;
+	u8	res1[3];
+	u8	ep_dma_unit;
+	u8	res2[3];
+	u8	ep_dma_fifo;
+	u8	res3[3];
+	u8	ep_dma_ttc_l;
+	u8	res4[3];
+	u8	ep_dma_ttc_m;
+	u8	res5[3];
+	u8	ep_dma_ttc_h;
+	u8	res6[3];
+#endif
+};
+
+struct s3c24x0_usb_device {
+#ifdef __BIG_ENDIAN
+	u8	res1[3];
+	u8	func_addr_reg;
+	u8	res2[3];
+	u8	pwr_reg;
+	u8	res3[3];
+	u8	ep_int_reg;
+	u8	res4[15];
+	u8	usb_int_reg;
+	u8	res5[3];
+	u8	ep_int_en_reg;
+	u8	res6[15];
+	u8	usb_int_en_reg;
+	u8	res7[3];
+	u8	frame_num1_reg;
+	u8	res8[3];
+	u8	frame_num2_reg;
+	u8	res9[3];
+	u8	index_reg;
+	u8	res10[7];
+	u8	maxp_reg;
+	u8	res11[3];
+	u8	ep0_csr_in_csr1_reg;
+	u8	res12[3];
+	u8	in_csr2_reg;
+	u8	res13[7];
+	u8	out_csr1_reg;
+	u8	res14[3];
+	u8	out_csr2_reg;
+	u8	res15[3];
+	u8	out_fifo_cnt1_reg;
+	u8	res16[3];
+	u8	out_fifo_cnt2_reg;
+#else /*  little endian */
+	u8	func_addr_reg;
+	u8	res1[3];
+	u8	pwr_reg;
+	u8	res2[3];
+	u8	ep_int_reg;
+	u8	res3[15];
+	u8	usb_int_reg;
+	u8	res4[3];
+	u8	ep_int_en_reg;
+	u8	res5[15];
+	u8	usb_int_en_reg;
+	u8	res6[3];
+	u8	frame_num1_reg;
+	u8	res7[3];
+	u8	frame_num2_reg;
+	u8	res8[3];
+	u8	index_reg;
+	u8	res9[7];
+	u8	maxp_reg;
+	u8	res10[7];
+	u8	ep0_csr_in_csr1_reg;
+	u8	res11[3];
+	u8	in_csr2_reg;
+	u8	res12[3];
+	u8	out_csr1_reg;
+	u8	res13[7];
+	u8	out_csr2_reg;
+	u8	res14[3];
+	u8	out_fifo_cnt1_reg;
+	u8	res15[3];
+	u8	out_fifo_cnt2_reg;
+	u8	res16[3];
+#endif /*  __BIG_ENDIAN */
+	struct s3c24x0_usb_dev_fifos	fifo[5];
+	struct s3c24x0_usb_dev_dmas	dma[5];
+};
+
+
+/* WATCH DOG TIMER (see manual chapter 18) */
+struct s3c24x0_watchdog {
+	u32	wtcon;
+	u32	wtdat;
+	u32	wtcnt;
+};
+
+/* IIS (see manual chapter 21) */
+struct s3c24x0_i2s {
+#ifdef __BIG_ENDIAN
+	u16	res1;
+	u16	iiscon;
+	u16	res2;
+	u16	iismod;
+	u16	res3;
+	u16	iispsr;
+	u16	res4;
+	u16	iisfcon;
+	u16	res5;
+	u16	iisfifo;
+#else /*  little endian */
+	u16	iiscon;
+	u16	res1;
+	u16	iismod;
+	u16	res2;
+	u16	iispsr;
+	u16	res3;
+	u16	iisfcon;
+	u16	res4;
+	u16	iisfifo;
+	u16	res5;
+#endif
+};
+
+
+/* I/O PORT (see manual chapter 9) */
+struct s3c24x0_gpio {
+#ifdef CONFIG_S3C2400
+	u32	pacon;
+	u32	padat;
+
+	u32	pbcon;
+	u32	pbdat;
+	u32	pbup;
+
+	u32	pccon;
+	u32	pcdat;
+	u32	pcup;
+
+	u32	pdcon;
+	u32	pddat;
+	u32	pdup;
+
+	u32	pecon;
+	u32	pedat;
+	u32	peup;
+
+	u32	pfcon;
+	u32	pfdat;
+	u32	pfup;
+
+	u32	pgcon;
+	u32	pgdat;
+	u32	pgup;
+
+	u32	opencr;
+
+	u32	misccr;
+	u32	extint;
+#endif
+#ifdef CONFIG_S3C2410
+	u32	gpacon;
+	u32	gpadat;
+	u32	res1[2];
+	u32	gpbcon;
+	u32	gpbdat;
+	u32	gpbup;
+	u32	res2;
+	u32	gpccon;
+	u32	gpcdat;
+	u32	gpcup;
+	u32	res3;
+	u32	gpdcon;
+	u32	gpddat;
+	u32	gpdup;
+	u32	res4;
+	u32	gpecon;
+	u32	gpedat;
+	u32	gpeup;
+	u32	res5;
+	u32	gpfcon;
+	u32	gpfdat;
+	u32	gpfup;
+	u32	res6;
+	u32	gpgcon;
+	u32	gpgdat;
+	u32	gpgup;
+	u32	res7;
+	u32	gphcon;
+	u32	gphdat;
+	u32	gphup;
+	u32	res8;
+
+	u32	misccr;
+	u32	dclkcon;
+	u32	extint0;
+	u32	extint1;
+	u32	extint2;
+	u32	eintflt0;
+	u32	eintflt1;
+	u32	eintflt2;
+	u32	eintflt3;
+	u32	eintmask;
+	u32	eintpend;
+	u32	gstatus0;
+	u32	gstatus1;
+	u32	gstatus2;
+	u32	gstatus3;
+	u32	gstatus4;
+#endif
+#if defined(CONFIG_S3C2440)
+	u32	gpacon;
+	u32	gpadat;
+	u32	res1[2];
+	u32	gpbcon;
+	u32	gpbdat;
+	u32	gpbup;
+	u32	res2;
+	u32	gpccon;
+	u32	gpcdat;
+	u32	gpcup;
+	u32	res3;
+	u32	gpdcon;
+	u32	gpddat;
+	u32	gpdup;
+	u32	res4;
+	u32	gpecon;
+	u32	gpedat;
+	u32	gpeup;
+	u32	res5;
+	u32	gpfcon;
+	u32	gpfdat;
+	u32	gpfup;
+	u32	res6;
+	u32	gpgcon;
+	u32	gpgdat;
+	u32	gpgup;
+	u32	res7;
+	u32	gphcon;
+	u32	gphdat;
+	u32	gphup;
+	u32	res8;
+
+	u32	misccr;
+	u32	dclkcon;
+	u32	extint0;
+	u32	extint1;
+	u32	extint2;
+	u32	eintflt0;
+	u32	eintflt1;
+	u32	eintflt2;
+	u32	eintflt3;
+	u32	eintmask;
+	u32	eintpend;
+	u32	gstatus0;
+	u32	gstatus1;
+	u32	gstatus2;
+	u32	gstatus3;
+	u32	gstatus4;
+
+	u32	res9;
+	u32	dsc0;
+	u32	dsc1;
+	u32	mslcon;
+	u32	gpjcon;
+	u32	gpjdat;
+	u32	gpjup;
+	u32	res10;
+#endif
+};
+
+
+/* RTC (see manual chapter 17) */
+struct s3c24x0_rtc {
+#ifdef __BIG_ENDIAN
+	u8	res1[67];
+	u8	rtccon;
+	u8	res2[3];
+	u8	ticnt;
+	u8	res3[11];
+	u8	rtcalm;
+	u8	res4[3];
+	u8	almsec;
+	u8	res5[3];
+	u8	almmin;
+	u8	res6[3];
+	u8	almhour;
+	u8	res7[3];
+	u8	almdate;
+	u8	res8[3];
+	u8	almmon;
+	u8	res9[3];
+	u8	almyear;
+	u8	res10[3];
+	u8	rtcrst;
+	u8	res11[3];
+	u8	bcdsec;
+	u8	res12[3];
+	u8	bcdmin;
+	u8	res13[3];
+	u8	bcdhour;
+	u8	res14[3];
+	u8	bcddate;
+	u8	res15[3];
+	u8	bcdday;
+	u8	res16[3];
+	u8	bcdmon;
+	u8	res17[3];
+	u8	bcdyear;
+#else /*  little endian */
+	u8	res0[64];
+	u8	rtccon;
+	u8	res1[3];
+	u8	ticnt;
+	u8	res2[11];
+	u8	rtcalm;
+	u8	res3[3];
+	u8	almsec;
+	u8	res4[3];
+	u8	almmin;
+	u8	res5[3];
+	u8	almhour;
+	u8	res6[3];
+	u8	almdate;
+	u8	res7[3];
+	u8	almmon;
+	u8	res8[3];
+	u8	almyear;
+	u8	res9[3];
+	u8	rtcrst;
+	u8	res10[3];
+	u8	bcdsec;
+	u8	res11[3];
+	u8	bcdmin;
+	u8	res12[3];
+	u8	bcdhour;
+	u8	res13[3];
+	u8	bcddate;
+	u8	res14[3];
+	u8	bcdday;
+	u8	res15[3];
+	u8	bcdmon;
+	u8	res16[3];
+	u8	bcdyear;
+	u8	res17[3];
+#endif
+};
+
+
+/* ADC (see manual chapter 16) */
+struct s3c2400_adc {
+	u32	adccon;
+	u32	adcdat;
+};
+
+
+/* ADC (see manual chapter 16) */
+struct s3c2410_adc {
+	u32	adccon;
+	u32	adctsc;
+	u32	adcdly;
+	u32	adcdat0;
+	u32	adcdat1;
+};
+
+
+/* SPI (see manual chapter 22) */
+struct s3c24x0_spi_channel {
+	u8	spcon;
+	u8	res1[3];
+	u8	spsta;
+	u8	res2[3];
+	u8	sppin;
+	u8	res3[3];
+	u8	sppre;
+	u8	res4[3];
+	u8	sptdat;
+	u8	res5[3];
+	u8	sprdat;
+	u8	res6[3];
+	u8	res7[16];
+};
+
+struct s3c24x0_spi {
+	struct s3c24x0_spi_channel	ch[S3C24X0_SPI_CHANNELS];
+};
+
+
+/* MMC INTERFACE (see S3C2400 manual chapter 19) */
+struct s3c2400_mmc {
+#ifdef __BIG_ENDIAN
+	u8	res1[3];
+	u8	mmcon;
+	u8	res2[3];
+	u8	mmcrr;
+	u8	res3[3];
+	u8	mmfcon;
+	u8	res4[3];
+	u8	mmsta;
+	u16	res5;
+	u16	mmfsta;
+	u8	res6[3];
+	u8	mmpre;
+	u16	res7;
+	u16	mmlen;
+	u8	res8[3];
+	u8	mmcr7;
+	u32	mmrsp[4];
+	u8	res9[3];
+	u8	mmcmd0;
+	u32	mmcmd1;
+	u16	res10;
+	u16	mmcr16;
+	u8	res11[3];
+	u8	mmdat;
+#else
+	u8	mmcon;
+	u8	res1[3];
+	u8	mmcrr;
+	u8	res2[3];
+	u8	mmfcon;
+	u8	res3[3];
+	u8	mmsta;
+	u8	res4[3];
+	u16	mmfsta;
+	u16	res5;
+	u8	mmpre;
+	u8	res6[3];
+	u16	mmlen;
+	u16	res7;
+	u8	mmcr7;
+	u8	res8[3];
+	u32	mmrsp[4];
+	u8	mmcmd0;
+	u8	res9[3];
+	u32	mmcmd1;
+	u16	mmcr16;
+	u16	res10;
+	u8	mmdat;
+	u8	res11[3];
+#endif
+};
+
+
+/* SD INTERFACE (see S3C2410 manual chapter 19) */
+struct s3c24x0_sdi {
+	u32	sdicon;
+	u32	sdipre;
+	u32	sdicarg;
+	u32	sdiccon;
+	u32	sdicsta;
+	u32	sdirsp0;
+	u32	sdirsp1;
+	u32	sdirsp2;
+	u32	sdirsp3;
+	u32	sdidtimer;
+	u32	sdibsize;
+	u32	sdidcon;
+	u32	sdidcnt;
+	u32	sdidsta;
+	u32	sdifsta;
+#ifdef CONFIG_S3C2410
+	u32	sdidat;
+	u32	sdiimsk;
+#else
+	u32	sdiimsk;
+	u32	sdidat;
+#endif
+};
+
+#ifdef CONFIG_CMD_MMC
+#include <mmc.h>
+int s3cmmc_initialize(bd_t *bis, int (*getcd)(struct mmc *),
+		      int (*getwp)(struct mmc *));
+#endif
+
+#endif /*__S3C24X0_H__*/
diff -urN u-boot-2020.07/arch/arm/include/asm/mach-types.h u-boot_2020.07_100ask/arch/arm/include/asm/mach-types.h
--- u-boot-2020.07/arch/arm/include/asm/mach-types.h	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/include/asm/mach-types.h	2020-08-03 18:15:02.807102497 +0800
@@ -368,6 +368,7 @@
 #define MACH_TYPE_POCKETSERV9200       360
 #define MACH_TYPE_TOTO                 361
 #define MACH_TYPE_S3C2440              362
+#define MACH_TYPE_JZ2440              MACH_TYPE_S3C2440
 #define MACH_TYPE_KS8695P              363
 #define MACH_TYPE_SE4000               364
 #define MACH_TYPE_QUADRICEPS           365
diff -urN u-boot-2020.07/arch/arm/Kconfig u-boot_2020.07_100ask/arch/arm/Kconfig
--- u-boot-2020.07/arch/arm/Kconfig	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/arch/arm/Kconfig	2020-08-03 18:15:02.775102203 +0800
@@ -1718,6 +1718,13 @@
 	bool "Support Cortina Presidio ASIC Platform"
 	select ARM64
 
+config TARGET_JZ2440
+	bool "support jz2440"
+	select CPU_ARM920T
+	select SUPPORT_SPL
+	help
+	  Support jz2440, a board based on S3C2440
+
 endchoice
 
 config ARCH_SUPPORT_TFABOOT
@@ -1922,6 +1929,9 @@
 source "board/xilinx/zynqmp/Kconfig"
 source "board/phytium/durian/Kconfig"
 
+#DaQui Modified
+source "board/100ask/jz2440/Kconfig"
+
 source "arch/arm/Kconfig.debug"
 
 endmenu
diff -urN u-boot-2020.07/board/100ask/jz2440/init.c u-boot_2020.07_100ask/board/100ask/jz2440/init.c
--- u-boot-2020.07/board/100ask/jz2440/init.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/board/100ask/jz2440/init.c	2020-08-03 18:15:02.919103516 +0800
@@ -0,0 +1,216 @@
+#ifdef CONFIG_SPL_BUILD
+
+#define CONFIG_SPL_NAND_IMAGE_BASE (0x20000)
+#define CONFIG_SPL_RELOC_DEST_ADDR (0x33F00000)
+#define CONFIG_SPL_RELOC_LEN 	   (0x40000)
+
+
+/* NAND FLASH¿ØÖÆÆ÷ */
+#define NFCONF (*((volatile unsigned long *)0x4E000000))
+#define NFCONT (*((volatile unsigned long *)0x4E000004))
+#define NFCMMD (*((volatile unsigned char *)0x4E000008))
+#define NFADDR (*((volatile unsigned char *)0x4E00000C))
+#define NFDATA (*((volatile unsigned char *)0x4E000010))
+#define NFSTAT (*((volatile unsigned char *)0x4E000020))
+
+/* GPIO */
+#define GPHCON              (*(volatile unsigned long *)0x56000070)
+#define GPHUP               (*(volatile unsigned long *)0x56000078)
+
+/* UART registers*/
+#define ULCON0              (*(volatile unsigned long *)0x50000000)
+#define UCON0               (*(volatile unsigned long *)0x50000004)
+#define UFCON0              (*(volatile unsigned long *)0x50000008)
+#define UMCON0              (*(volatile unsigned long *)0x5000000c)
+#define UTRSTAT0            (*(volatile unsigned long *)0x50000010)
+#define UTXH0               (*(volatile unsigned char *)0x50000020)
+#define URXH0               (*(volatile unsigned char *)0x50000024)
+#define UBRDIV0             (*(volatile unsigned long *)0x50000028)
+
+#define TXD0READY   (1<<2)
+
+
+void nand_read_ll(unsigned int addr, unsigned char *buf, unsigned int len);
+
+
+int isBootFromNorFlash(void)
+{
+	volatile int *p = (volatile int *)0;
+	int val;
+
+	val = *p;
+	*p = 0x12345678;
+	if (*p == 0x12345678)
+	{
+		/* Ð´³É¹¦, ÊÇnandÆô¶¯ */
+		*p = val;
+		return 0;
+	}
+	else
+	{
+		/* NOR²»ÄÜÏñÄÚ´æÒ»ÑùÐ´ */
+		return 1;
+	}
+}
+
+void copy_code_to_sdram(unsigned char *src, unsigned char *dest, unsigned int len)
+{	
+	int i = 0;
+	
+	/* Èç¹ûÊÇNORÆô¶¯ */
+	if (isBootFromNorFlash())
+	{
+		while (i < len)
+		{
+			dest[i] = src[i];
+			i++;
+		}
+	}
+	else
+	{
+		//nand_init();
+		nand_read_ll((unsigned int)src, dest, len);
+	}
+}
+
+void nand_init_ll(void)
+{
+#define TACLS   0
+#define TWRPH0  1
+#define TWRPH1  0
+	/* ÉèÖÃÊ±Ðò */
+	NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
+	/* Ê¹ÄÜNAND Flash¿ØÖÆÆ÷, ³õÊ¼»¯ECC, ½ûÖ¹Æ¬Ñ¡ */
+	NFCONT = (1<<4)|(1<<1)|(1<<0);	
+}
+
+void nand_select_ll(void)
+{
+	NFCONT &= ~(1<<1);	
+}
+
+void nand_deselect_ll(void)
+{
+	NFCONT |= (1<<1);	
+}
+
+void nand_cmd_ll(unsigned char cmd)
+{
+	volatile int i;
+	NFCMMD = cmd;
+	for (i = 0; i < 10; i++);
+}
+
+void nand_addr_ll(unsigned int addr)
+{
+	unsigned int col  = addr % 2048;
+	unsigned int page = addr / 2048;
+	volatile int i;
+
+	NFADDR = col & 0xff;
+	for (i = 0; i < 10; i++);
+	NFADDR = (col >> 8) & 0xff;
+	for (i = 0; i < 10; i++);
+	
+	NFADDR  = page & 0xff;
+	for (i = 0; i < 10; i++);
+	NFADDR  = (page >> 8) & 0xff;
+	for (i = 0; i < 10; i++);
+	NFADDR  = (page >> 16) & 0xff;
+	for (i = 0; i < 10; i++);	
+}
+
+void nand_wait_ready_ll(void)
+{
+	while (!(NFSTAT & 1));
+}
+
+unsigned char nand_data_ll(void)
+{
+	return NFDATA;
+}
+
+void nand_read_ll(unsigned int addr, unsigned char *buf, unsigned int len)
+{
+	int col = addr % 2048;
+	int i = 0;
+		
+	/* 1. Ñ¡ÖÐ */
+	nand_select_ll();
+
+	while (i < len)
+	{
+		/* 2. ·¢³ö¶ÁÃüÁî00h */
+		nand_cmd_ll(0x00);
+
+		/* 3. ·¢³öµØÖ·(·Ö5²½·¢³ö) */
+		nand_addr_ll(addr);
+
+		/* 4. ·¢³ö¶ÁÃüÁî30h */
+		nand_cmd_ll(0x30);
+
+		/* 5. ÅÐ¶Ï×´Ì¬ */
+		nand_wait_ready_ll();
+
+		/* 6. ¶ÁÊý¾Ý */
+		for (; (col < 2048) && (i < len); col++)
+		{
+			buf[i] = nand_data_ll();
+			i++;
+			addr++;
+		}
+		
+		col = 0;
+	}
+
+	/* 7. È¡ÏûÑ¡ÖÐ */		
+	nand_deselect_ll();
+}
+
+void fix_reldyn_ll(void)
+{
+/*
+	extern char __rel_dyn_start[0];
+	extern char __rel_dyn_end[0];
+	
+	char *rd_startp = __rel_dyn_start;
+	char *rd_endp = __rel_dyn_end;
+*/
+#if 0
+		/*
+		 * fix .rel.dyn relocations
+		 */
+		ldr r2, =__rel_dyn_start	/* r2 <- SRC &__rel_dyn_start */
+		ldr r3, =__rel_dyn_end	/* r3 <- SRC &__rel_dyn_end */
+	fixloop:
+		ldmia	r2!, {r0-r1}		/* (r0,r1) <- (SRC location,fixup) */
+		and r1, r1, #0xff
+		cmp r1, #23 		/* relative fixup? */
+		bne fixnext
+	
+		/* relative fix: increase location by offset */
+		add r0, r0, r4
+		ldr r1, [r0]
+		add r1, r1, r4
+		str r1, [r0]
+	fixnext:
+		cmp r2, r3
+		blo fixloop
+#endif
+}
+
+void board_init_f(unsigned long boot_flags)
+{
+	nand_init_ll();
+	copy_code_to_sdram((unsigned char *)CONFIG_SPL_NAND_IMAGE_BASE, (unsigned char *)CONFIG_SPL_RELOC_DEST_ADDR, CONFIG_SPL_RELOC_LEN);
+	fix_reldyn_ll();
+	
+	__attribute__((noreturn)) void (*uboot)(void);
+	 /* Jump to U-Boot image */
+	uboot = (void *)CONFIG_SPL_RELOC_DEST_ADDR;
+	(*uboot)();
+	/* Never returns Here */
+}
+
+#endif /* CONFIG_SPL_BUILD */
+
diff -urN u-boot-2020.07/board/100ask/jz2440/jz2440.c u-boot_2020.07_100ask/board/100ask/jz2440/jz2440.c
--- u-boot-2020.07/board/100ask/jz2440/jz2440.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/board/100ask/jz2440/jz2440.c	2020-08-03 18:15:02.919103516 +0800
@@ -0,0 +1,163 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002, 2010
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <net.h>
+#include <env.h>
+#include <cpu_func.h>
+#include <flash.h>
+#include <asm/io.h>
+#include <asm/arch-s3c24x0/s3c24x0_cpu.h>
+#include <asm/mach-types.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define FCLK_SPEED 1
+
+#if (FCLK_SPEED == 0)		/* Fout = 203MHz, Fin = 12MHz for Audio */
+#define M_MDIV	0xC3
+#define M_PDIV	0x4
+#define M_SDIV	0x1
+#elif (FCLK_SPEED == 1)		/* Fout = 202.8MHz */
+#define M_MDIV	0xA1
+#define M_PDIV	0x3
+#define M_SDIV	0x1
+#endif
+
+#define USB_CLOCK 1
+
+#if (USB_CLOCK == 0)
+#define U_M_MDIV	0xA1
+#define U_M_PDIV	0x3
+#define U_M_SDIV	0x1
+#elif (USB_CLOCK == 1)
+#define U_M_MDIV	0x48
+#define U_M_PDIV	0x3
+#define U_M_SDIV	0x2
+#endif
+
+static inline void pll_delay(unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+	  "subs %0, %1, #1\n"
+	  "bne 1b" : "=r" (loops) : "0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_early_init_f(void)
+{
+	struct s3c24x0_gpio * const gpio = s3c24x0_get_base_gpio();
+
+#ifndef CONFIG_JZ2440 
+	struct s3c24x0_clock_power * const clk_power =
+					s3c24x0_get_base_clock_power();
+
+	/* to reduce PLL lock time, adjust the LOCKTIME register */
+	writel(0xFFFFFF, &clk_power->locktime);
+
+	/* configure MPLL */
+	writel((M_MDIV << 12) + (M_PDIV << 4) + M_SDIV,
+	       &clk_power->mpllcon);
+
+	/* some delay between MPLL and UPLL */
+	pll_delay(4000);
+
+	/* configure UPLL */
+	writel((U_M_MDIV << 12) + (U_M_PDIV << 4) + U_M_SDIV,
+	       &clk_power->upllcon);
+
+	/* some delay between MPLL and UPLL */
+	pll_delay(8000);
+#endif
+
+	/* set up the I/O ports */
+	writel(0x007FFFFF, &gpio->gpacon);
+	writel(0x00044555, &gpio->gpbcon);
+	writel(0x000007FF, &gpio->gpbup);
+	writel(0xAAAAAAAA, &gpio->gpccon);
+	writel(0x0000FFFF, &gpio->gpcup);
+	writel(0xAAAAAAAA, &gpio->gpdcon);
+	writel(0x0000FFFF, &gpio->gpdup);
+	writel(0xAAAAAAAA, &gpio->gpecon);
+	writel(0x0000FFFF, &gpio->gpeup);
+	writel(0x000055AA, &gpio->gpfcon);
+	writel(0x000000FF, &gpio->gpfup);
+	writel(0xFF95FFBA, &gpio->gpgcon);
+	writel(0x0000FFFF, &gpio->gpgup);
+	writel(0x002AFAAA, &gpio->gphcon);
+	writel(0x000007FF, &gpio->gphup);
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* arch number of SMDK2410-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_JZ2440;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x30000100;
+
+	icache_enable();
+	dcache_enable();
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	/* dram_init must store complete ramsize in gd->ram_size */
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+#ifdef CONFIG_CMD_NET
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+	unsigned char mac_addr[6];
+
+	/* DaQui modified */
+	
+	mac_addr[0] = 0x60;
+	mac_addr[1] = 0xF2;
+	mac_addr[2] = 0xEF;
+	mac_addr[3] = 0x03;
+	mac_addr[4] = 0x03;
+	mac_addr[5] = 0x1F;
+
+	if (!env_get("ethaddr")) {
+			puts("<ethaddr> not set. Validating first E-fuse MAC\n");
+			if (is_valid_ethaddr(mac_addr))
+					eth_env_set_enetaddr("ethaddr", mac_addr);
+	}
+	
+	rc = dm9000_initialize(bis);
+	
+	return rc;
+}
+#endif
+
+/*
+ * Hardcoded flash setup:
+ * Flash 0 is a non-CFI AMD AM29LV800BB flash.
+ */
+ulong board_flash_get_legacy(ulong base, int banknum, flash_info_t *info)
+{
+	info->portwidth = FLASH_CFI_16BIT;
+	info->chipwidth = FLASH_CFI_BY16;
+	info->interface = FLASH_CFI_X16;
+	return 1;
+}
diff -urN u-boot-2020.07/board/100ask/jz2440/Kconfig u-boot_2020.07_100ask/board/100ask/jz2440/Kconfig
--- u-boot-2020.07/board/100ask/jz2440/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/board/100ask/jz2440/Kconfig	2020-08-03 18:15:02.919103516 +0800
@@ -0,0 +1,15 @@
+if TARGET_JZ2440
+
+config SYS_BOARD
+	default "jz2440"
+
+config SYS_VENDOR
+	default "100ask"
+
+config SYS_SOC
+	default "s3c24x0"
+
+config SYS_CONFIG_NAME
+	default "jz2440"
+
+endif
diff -urN u-boot-2020.07/board/100ask/jz2440/lowlevel_init.S u-boot_2020.07_100ask/board/100ask/jz2440/lowlevel_init.S
--- u-boot-2020.07/board/100ask/jz2440/lowlevel_init.S	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/board/100ask/jz2440/lowlevel_init.S	2020-08-03 18:15:02.919103516 +0800
@@ -0,0 +1,166 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+
+#include <config.h>
+
+/* some parameters for the board */
+
+/*
+ *
+ * Taken from linux/arch/arm/boot/compressed/head-s3c2410.S
+ *
+ * Copyright (C) 2002 Samsung Electronics SW.LEE  <hitchcar@sec.samsung.com>
+ *
+ */
+
+#define BWSCON	0x48000000
+
+/* BWSCON */
+#define DW8			(0x0)
+#define DW16			(0x1)
+#define DW32			(0x2)
+#define WAIT			(0x1<<2)
+#define UBLB			(0x1<<3)
+
+#define B1_BWSCON		(DW32)
+#define B2_BWSCON		(DW16)
+#define B3_BWSCON		(DW16 + WAIT + UBLB)
+#define B4_BWSCON		(DW16)
+#define B5_BWSCON		(DW16)
+#define B6_BWSCON		(DW32)
+#define B7_BWSCON		(DW32)
+
+/* BANK0CON */
+#define B0_Tacs			0x0	/*  0clk */
+#define B0_Tcos			0x0	/*  0clk */
+#define B0_Tacc			0x7	/* 14clk */
+#define B0_Tcoh			0x0	/*  0clk */
+#define B0_Tah			0x0	/*  0clk */
+#define B0_Tacp			0x0
+#define B0_PMC			0x0	/* normal */
+
+/* BANK1CON */
+#define B1_Tacs			0x0	/*  0clk */
+#define B1_Tcos			0x0	/*  0clk */
+#define B1_Tacc			0x7	/* 14clk */
+#define B1_Tcoh			0x0	/*  0clk */
+#define B1_Tah			0x0	/*  0clk */
+#define B1_Tacp			0x0
+#define B1_PMC			0x0
+
+#define B2_Tacs			0x0
+#define B2_Tcos			0x0
+#define B2_Tacc			0x7
+#define B2_Tcoh			0x0
+#define B2_Tah			0x0
+#define B2_Tacp			0x0
+#define B2_PMC			0x0
+
+#define B3_Tacs			0x0	/*  0clk */
+#define B3_Tcos			0x3	/*  4clk */
+#define B3_Tacc			0x7	/* 14clk */
+#define B3_Tcoh			0x1	/*  1clk */
+#define B3_Tah			0x0	/*  0clk */
+#define B3_Tacp			0x3     /*  6clk */
+#define B3_PMC			0x0	/* normal */
+
+#define B4_Tacs			0x0	/*  0clk */
+#define B4_Tcos			0x0	/*  0clk */
+#define B4_Tacc			0x7	/* 14clk */
+#define B4_Tcoh			0x0	/*  0clk */
+#define B4_Tah			0x0	/*  0clk */
+#define B4_Tacp			0x0
+#define B4_PMC			0x0	/* normal */
+
+#define B5_Tacs			0x0	/*  0clk */
+#define B5_Tcos			0x0	/*  0clk */
+#define B5_Tacc			0x7	/* 14clk */
+#define B5_Tcoh			0x0	/*  0clk */
+#define B5_Tah			0x0	/*  0clk */
+#define B5_Tacp			0x0
+#define B5_PMC			0x0	/* normal */
+
+#define B6_MT			0x3	/* SDRAM */
+#define B6_Trcd			0x1
+#define B6_SCAN			0x1	/* 9bit */
+
+#define B7_MT			0x3	/* SDRAM */
+#define B7_Trcd			0x1	/* 3clk */
+#define B7_SCAN			0x1	/* 9bit */
+
+/* REFRESH parameter */
+#define REFEN			0x1	/* Refresh enable */
+#define TREFMD			0x0	/* CBR(CAS before RAS)/Auto refresh */
+#define Trp			0x0	/* 2clk */
+#define Trc			0x3	/* 7clk */
+#define Tchr			0x2	/* 3clk */
+#define REFCNT			1113	/* period=15.6us, HCLK=60Mhz, (2048+1-15.6*60) */
+/**************************************/
+
+.globl lowlevel_init
+lowlevel_init:
+#ifdef CONFIG_SPL_BUILD /* DaQui modified */
+	#define S3C2440_MPLL_400MHZ     ((0x5c<<12)|(0x01<<4)|(0x01))
+	
+	/* å¦æHDIVNé0ï¼CPUçæ»çº¿æ¨¡å¼åºè¯¥ä»âfast bus modeâåä¸ºâasynchronous bus modeâ */
+	mrc	p15, 0, r1, c1, c0, 0		/* è¯»åºæ§å¶å¯å­å¨ */ 
+	orr	r1, r1, #0xc0000000			/* è®¾ç½®ä¸ºâasynchronous bus modeâ */
+	mcr	p15, 0, r1, c1, c0, 0		/* åå¥æ§å¶å¯å­å¨ */
+
+	/* MPLLCON = S3C2440_MPLL_200MHZ */
+	ldr r0, =0x4c000004
+	ldr r1, =S3C2440_MPLL_400MHZ
+	str r1, [r0]
+
+	/* å¯å¨ICACHE */
+	mrc p15, 0, r0, c1, c0, 0	@ read control reg
+	orr r0, r0, #(1<<12)
+	mcr	p15, 0, r0, c1, c0, 0   @ write it back
+	
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads SMRDATA out of FLASH rather than memory ! */
+	ldr     r0, =SMRDATA
+	ldr		r1, =CONFIG_SPL_TEXT_BASE/* DaQui modified */
+	sub		r0, r0, r1
+	ldr		r1, =BWSCON	/* Bus Width Status Controller */
+	add     r2, r0, #13*4
+0:
+	ldr     r3, [r0], #4
+	str     r3, [r1], #4
+	cmp     r2, r0
+	bne     0b
+
+	/* everything is fine now */
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+SMRDATA: /* DaQui modified */
+		.long 0x22011110		 //BWSCON
+		.long 0x00000700		 //BANKCON0
+		.long 0x00000700		 //BANKCON1
+		.long 0x00000700		 //BANKCON2
+		.long 0x00000700		 //BANKCON3
+		.long 0x00000740		 //BANKCON4
+		.long 0x00000700		 //BANKCON5
+		.long 0x00018005		 //BANKCON6
+		.long 0x00018005		 //BANKCON7
+		.long 0x008C04F4		 // REFRESH
+		.long 0x000000B1		 //BANKSIZE
+		.long 0x00000030		 //MRSRB6
+		.long 0x00000030		 //MRSRB7
+#else  /* !CONFIG_SPL_BUILD */
+	mov	pc, lr /* skip low level init */
+#endif /* end CONFIG_SPL_BUILD */
diff -urN u-boot-2020.07/board/100ask/jz2440/MAINTAINERS u-boot_2020.07_100ask/board/100ask/jz2440/MAINTAINERS
--- u-boot-2020.07/board/100ask/jz2440/MAINTAINERS	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/board/100ask/jz2440/MAINTAINERS	2020-08-03 18:15:02.919103516 +0800
@@ -0,0 +1,6 @@
+SMDK2410 BOARD
+M:	David MÃ¼ller <d.mueller@elsoft.ch>
+S:	Maintained
+F:	board/samsung/smdk2410/
+F:	include/configs/smdk2410.h
+F:	configs/smdk2410_defconfig
diff -urN u-boot-2020.07/board/100ask/jz2440/Makefile u-boot_2020.07_100ask/board/100ask/jz2440/Makefile
--- u-boot-2020.07/board/100ask/jz2440/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/board/100ask/jz2440/Makefile	2020-08-03 18:15:02.919103516 +0800
@@ -0,0 +1,10 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	:= jz2440.o
+obj-y	+= lowlevel_init.o
+obj-y	+= init.o
diff -urN u-boot-2020.07/cmd/nand.c u-boot_2020.07_100ask/cmd/nand.c
--- u-boot-2020.07/cmd/nand.c	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/cmd/nand.c	2020-08-03 18:15:02.923103554 +0800
@@ -632,6 +632,19 @@
 						maxsize, (u_char *)addr,
 						WITH_DROP_FFS | WITH_WR_VERIFY);
 #endif
+#ifdef CONFIG_CMD_NAND_YAFFS /*DaQui modified*/
+		} else if (!strcmp(s, ".yaffs")) {
+				if (read) {
+						printf("Unknown nand command suffix '%s'.\n", s);
+						return 1;
+				}
+
+			ret = nand_write_skip_bad(mtd, off, &rwsize, NULL,
+						maxsize, (u_char *)addr,
+						WITH_YAFFS_OOB);
+#endif
+			   
+
 		} else if (!strcmp(s, ".oob")) {
 			/* out-of-band data */
 			mtd_oob_ops_t ops = {
@@ -808,6 +821,11 @@
 	"    write 'size' bytes starting at offset 'off' from memory address\n"
 	"    'addr', skipping bad blocks and dropping any pages at the end\n"
 	"    of eraseblocks that contain only 0xFF\n"
+#endif	
+#ifdef CONFIG_CMD_NAND_YAFFS /*DaQui modified*/
+			"nand write.yaffs - addr off|partition size\n"
+			"		 write 'size' bytes starting at offset 'off' with yaffs format\n"
+			"		 from memory address 'addr', skipping bad blocks.\n"
 #endif
 	"nand erase[.spread] [clean] off size - erase 'size' bytes "
 	"from offset 'off'\n"
diff -urN u-boot-2020.07/common/init/board_init.c u-boot_2020.07_100ask/common/init/board_init.c
--- u-boot-2020.07/common/init/board_init.c	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/common/init/board_init.c	2020-08-03 18:15:02.923103554 +0800
@@ -131,7 +131,11 @@
 void board_init_f_init_reserve(ulong base)
 {
 	struct global_data *gd_ptr;
-
+#if 0
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_JZ2440)
+	int *ptr;
+#endif
+#endif
 	/*
 	 * clear GD entirely and set it up.
 	 * Use gd_ptr, as gd may not be properly set yet.
@@ -140,6 +144,14 @@
 	gd_ptr = (struct global_data *)base;
 	/* zero the area */
 	memset(gd_ptr, '\0', sizeof(*gd));
+#if 0
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_JZ2440)
+	for (ptr = (int *)gd_ptr; ptr < (int *)(gd_ptr + 1); )
+		*ptr++ = 0;
+#else
+	memset(gd_ptr, '\0', sizeof(*gd));
+#endif
+#endif
 	/* set GD unless architecture did it already */
 #if !defined(CONFIG_ARM)
 	arch_setup_gd(gd_ptr);
diff -urN u-boot-2020.07/config_ok u-boot_2020.07_100ask/config_ok
--- u-boot-2020.07/config_ok	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/config_ok	2020-08-03 18:15:02.775102203 +0800
@@ -0,0 +1,1065 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2020.07 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_PPC is not set
+# CONFIG_RISCV is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="arm920t"
+CONFIG_SYS_SOC="s3c24x0"
+CONFIG_SYS_VENDOR="100ask"
+CONFIG_SYS_BOARD="jz2440"
+CONFIG_SYS_CONFIG_NAME="jz2440"
+# CONFIG_SYS_ICACHE_OFF is not set
+# CONFIG_SYS_DCACHE_OFF is not set
+
+#
+# ARM architecture
+#
+# CONFIG_GIC_V3_ITS is not set
+CONFIG_ARM_ASM_UNIFIED=y
+CONFIG_SYS_ARM_CACHE_CP15=y
+CONFIG_SYS_ARM_MMU=y
+# CONFIG_SYS_ARM_MPU is not set
+CONFIG_CPU_ARM920T=y
+CONFIG_SYS_ARM_ARCH=4
+CONFIG_SYS_CACHE_SHIFT_5=y
+CONFIG_SYS_CACHELINE_SIZE=32
+CONFIG_SYS_ARM_CACHE_WRITEBACK=y
+# CONFIG_SYS_ARM_CACHE_WRITETHROUGH is not set
+# CONFIG_SYS_ARM_CACHE_WRITEALLOC is not set
+# CONFIG_ARCH_CPU_INIT is not set
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_THUMB_BUILD is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+# CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK is not set
+CONFIG_USE_ARCH_MEMCPY=y
+CONFIG_USE_ARCH_MEMSET=y
+# CONFIG_SET_STACK_SIZE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_ARCH_BCM63158 is not set
+# CONFIG_ARCH_BCM68360 is not set
+# CONFIG_ARCH_BCM6858 is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_ARCH_BCMSTB is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_TARGET_BCMNS2 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_K3 is not set
+# CONFIG_ARCH_OMAP2PLUS is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_IMX8 is not set
+# CONFIG_ARCH_IMX8M is not set
+# CONFIG_ARCH_IMXRT is not set
+# CONFIG_ARCH_MX23 is not set
+# CONFIG_ARCH_MX25 is not set
+# CONFIG_ARCH_MX28 is not set
+# CONFIG_ARCH_MX31 is not set
+# CONFIG_ARCH_MX7ULP is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_ARCH_OWL is not set
+# CONFIG_ARCH_QEMU is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_VERSAL is not set
+# CONFIG_ARCH_VF610 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP_R5 is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS1088AQDS is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_LS2081ARDB is not set
+# CONFIG_TARGET_LX2160ARDB is not set
+# CONFIG_TARGET_LX2160AQDS is not set
+# CONFIG_TARGET_HIKEY is not set
+# CONFIG_TARGET_HIKEY960 is not set
+# CONFIG_TARGET_POPLAR is not set
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012A2G5RDB is not set
+# CONFIG_TARGET_LS1012AFRWY is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1028AQDS is not set
+# CONFIG_TARGET_LS1028ARDB is not set
+# CONFIG_TARGET_LS1088ARDB is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1021ATSN is not set
+# CONFIG_TARGET_LS1021AIOT is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_LS1046AFRWY is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_ARCH_STM32 is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_STM32MP is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+# CONFIG_ARCH_ASPEED is not set
+# CONFIG_TARGET_DURIAN is not set
+# CONFIG_TARGET_PRESIDIO_ASIC is not set
+CONFIG_TARGET_JZ2440=y
+CONFIG_SYS_TEXT_BASE=0x33F00000
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_OFFSET=0x60000
+CONFIG_ERR_PTR_OFFSET=0x0
+CONFIG_NR_DRAM_BANKS=1
+# CONFIG_SPL is not set
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_IDENT_STRING=""
+CONFIG_CSF_SIZE=0x2060
+# CONFIG_CMD_DEKBLOB is not set
+# CONFIG_CMD_HDMIDETECT is not set
+# CONFIG_CMD_NANDBCB is not set
+CONFIG_IMX_DCD_ADDR=0x00910000
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+CONFIG_BUILD_TARGET=""
+# CONFIG_DEBUG_UART is not set
+# CONFIG_OF_BOARD_FIXUP is not set
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_DISTRO_DEFAULTS is not set
+# CONFIG_ENV_VARS_UBOOT_CONFIG is not set
+# CONFIG_SYS_BOOT_GET_CMDLINE is not set
+# CONFIG_SYS_BOOT_GET_KBD is not set
+# CONFIG_SYS_MALLOC_F is not set
+CONFIG_EXPERT=y
+CONFIG_SYS_MALLOC_CLEAR_ON_INIT=y
+# CONFIG_SYS_MALLOC_DEFAULT_TO_INIT is not set
+# CONFIG_TOOLS_DEBUG is not set
+# CONFIG_PHYS_64BIT is not set
+# CONFIG_SYS_CUSTOM_LDSCRIPT is not set
+CONFIG_PLATFORM_ELFENTRY="_start"
+
+#
+# Boot images
+#
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+# CONFIG_FIT is not set
+CONFIG_LEGACY_IMAGE_FORMAT=y
+CONFIG_SYS_EXTRA_OPTIONS=""
+CONFIG_HAVE_SYS_TEXT_BASE=y
+CONFIG_ARCH_FIXUP_FDT_MEMORY=y
+
+#
+# API
+#
+# CONFIG_API is not set
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_RECORD_COUNT=30
+CONFIG_SPL_BOOTSTAGE_RECORD_COUNT=5
+CONFIG_TPL_BOOTSTAGE_RECORD_COUNT=5
+CONFIG_BOOTSTAGE_STASH_SIZE=0x1000
+# CONFIG_SHOW_BOOT_PROGRESS is not set
+
+#
+# Boot media
+#
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+# CONFIG_SD_BOOT is not set
+# CONFIG_SPI_BOOT is not set
+CONFIG_BOOTDELAY=3
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttySAC0 root=/dev/mtdblock4"
+# CONFIG_USE_BOOTCOMMAND is not set
+# CONFIG_USE_PREBOOT is not set
+
+#
+# Console
+#
+# CONFIG_CONSOLE_RECORD is not set
+# CONFIG_DISABLE_CONSOLE is not set
+CONFIG_LOGLEVEL=4
+CONFIG_SPL_LOGLEVEL=4
+CONFIG_TPL_LOGLEVEL=4
+# CONFIG_SILENT_CONSOLE is not set
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+# CONFIG_CONSOLE_MUX is not set
+# CONFIG_SYS_CONSOLE_IS_IN_ENV is not set
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+# CONFIG_SYS_CONSOLE_ENV_OVERWRITE is not set
+# CONFIG_SYS_CONSOLE_INFO_QUIET is not set
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+
+#
+# Logging
+#
+CONFIG_LOG_DEFAULT_LEVEL=6
+# CONFIG_SUPPORT_RAW_INITRD is not set
+CONFIG_DEFAULT_FDT_FILE=""
+# CONFIG_MISC_INIT_R is not set
+# CONFIG_VERSION_VARIABLE is not set
+# CONFIG_BOARD_LATE_INIT is not set
+CONFIG_DISPLAY_CPUINFO=y
+CONFIG_DISPLAY_BOARDINFO=y
+# CONFIG_DISPLAY_BOARDINFO_LATE is not set
+# CONFIG_BOUNCE_BUFFER is not set
+# CONFIG_BOARD_TYPES is not set
+
+#
+# Start-up hooks
+#
+# CONFIG_ARCH_EARLY_INIT_R is not set
+# CONFIG_ARCH_MISC_INIT is not set
+# CONFIG_BOARD_EARLY_INIT_F is not set
+# CONFIG_BOARD_EARLY_INIT_R is not set
+# CONFIG_LAST_STAGE_INIT is not set
+
+#
+# Security support
+#
+CONFIG_HASH=y
+
+#
+# Update support
+#
+# CONFIG_ANDROID_AB is not set
+
+#
+# Blob list
+#
+# CONFIG_BLOBLIST is not set
+
+#
+# SPL / TPL
+#
+CONFIG_SUPPORT_SPL=y
+CONFIG_SPL_SYS_STACK_F_CHECK_BYTE=0xaa
+# CONFIG_SPL_SYS_REPORT_STACK_F_USAGE is not set
+
+#
+# PowerPC and LayerScape SPL Boot options
+#
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_SYS_LONGHELP=y
+CONFIG_SYS_PROMPT="Jz2440 # "
+CONFIG_SYS_XTRACE="y"
+
+#
+# Autoboot options
+#
+CONFIG_AUTOBOOT=y
+# CONFIG_AUTOBOOT_KEYED is not set
+# CONFIG_AUTOBOOT_USE_MENUKEY is not set
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+# CONFIG_CMD_ACPI is not set
+CONFIG_CMD_BDI=y
+# CONFIG_CMD_CONFIG is not set
+CONFIG_CMD_CONSOLE=y
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+# CONFIG_CMD_PMC is not set
+
+#
+# Boot commands
+#
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_BOOTM=y
+# CONFIG_CMD_BOOTZ is not set
+CONFIG_BOOTM_LINUX=y
+# CONFIG_BOOTM_NETBSD is not set
+# CONFIG_BOOTM_OPENRTOS is not set
+# CONFIG_BOOTM_PLAN9 is not set
+# CONFIG_BOOTM_RTEMS is not set
+# CONFIG_BOOTM_VXWORKS is not set
+# CONFIG_CMD_BOOTMENU is not set
+# CONFIG_CMD_ADTIMG is not set
+# CONFIG_CMD_ELF is not set
+# CONFIG_CMD_GO is not set
+# CONFIG_CMD_RUN is not set
+# CONFIG_CMD_IMI is not set
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_XIMG is not set
+# CONFIG_CMD_THOR_DOWNLOAD is not set
+# CONFIG_CMD_ZBOOT is not set
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+# CONFIG_CMD_GREPENV is not set
+CONFIG_CMD_SAVEENV=y
+# CONFIG_CMD_ERASEENV is not set
+CONFIG_CMD_ENV_EXISTS=y
+# CONFIG_CMD_ENV_CALLBACK is not set
+# CONFIG_CMD_ENV_FLAGS is not set
+# CONFIG_CMD_NVEDIT_INFO is not set
+
+#
+# Memory commands
+#
+# CONFIG_CMD_BINOP is not set
+CONFIG_CMD_CRC32=y
+# CONFIG_CRC32_VERIFY is not set
+# CONFIG_CMD_EEPROM is not set
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MD5SUM is not set
+# CONFIG_CMD_MEMINFO is not set
+CONFIG_CMD_MEMORY=y
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_SHA1SUM is not set
+# CONFIG_CMD_STRINGS is not set
+
+#
+# Compression commands
+#
+# CONFIG_CMD_LZMADEC is not set
+# CONFIG_CMD_UNLZ4 is not set
+# CONFIG_CMD_UNZIP is not set
+# CONFIG_CMD_ZIP is not set
+
+#
+# Device access commands
+#
+# CONFIG_CMD_ARMFLASH is not set
+# CONFIG_CMD_ADC is not set
+# CONFIG_CMD_CLK is not set
+# CONFIG_CMD_DFU is not set
+CONFIG_CMD_FLASH=y
+# CONFIG_CMD_FPGAD is not set
+# CONFIG_CMD_FUSE is not set
+# CONFIG_CMD_GPIO is not set
+# CONFIG_CMD_GPT is not set
+# CONFIG_RANDOM_UUID is not set
+# CONFIG_CMD_IDE is not set
+# CONFIG_CMD_IO is not set
+# CONFIG_CMD_IOTRACE is not set
+# CONFIG_CMD_I2C is not set
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADS=y
+# CONFIG_CMD_MMC is not set
+# CONFIG_CMD_MTD is not set
+CONFIG_CMD_NAND=y
+# CONFIG_CMD_NAND_TRIMFFS is not set
+# CONFIG_CMD_NAND_LOCK_UNLOCK is not set
+# CONFIG_CMD_NAND_TORTURE is not set
+# CONFIG_CMD_ONENAND is not set
+# CONFIG_CMD_OSD is not set
+# CONFIG_CMD_PART is not set
+# CONFIG_CMD_PCI is not set
+# CONFIG_CMD_PINMUX is not set
+# CONFIG_CMD_POWEROFF is not set
+# CONFIG_CMD_READ is not set
+# CONFIG_CMD_SATA is not set
+# CONFIG_CMD_SAVES is not set
+# CONFIG_CMD_SCSI is not set
+# CONFIG_CMD_SDRAM is not set
+# CONFIG_CMD_TSI148 is not set
+# CONFIG_CMD_UNIVERSE is not set
+# CONFIG_CMD_USB is not set
+# CONFIG_CMD_USB_SDP is not set
+# CONFIG_CMD_USB_MASS_STORAGE is not set
+
+#
+# Shell scripting commands
+#
+# CONFIG_CMD_ECHO is not set
+# CONFIG_CMD_ITEST is not set
+# CONFIG_CMD_SOURCE is not set
+# CONFIG_CMD_SETEXPR is not set
+
+#
+# Android support commands
+#
+CONFIG_CMD_NET=y
+CONFIG_CMD_BOOTP=y
+# CONFIG_CMD_DHCP is not set
+# CONFIG_BOOTP_BOOTPATH is not set
+# CONFIG_BOOTP_DNS is not set
+# CONFIG_BOOTP_GATEWAY is not set
+# CONFIG_BOOTP_HOSTNAME is not set
+# CONFIG_BOOTP_PREFER_SERVERIP is not set
+# CONFIG_BOOTP_SUBNETMASK is not set
+# CONFIG_BOOTP_NTPSERVER is not set
+# CONFIG_CMD_PCAP is not set
+CONFIG_BOOTP_VCI_STRING="U-Boot.arm"
+CONFIG_CMD_TFTPBOOT=y
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+CONFIG_NET_TFTP_VARS=y
+# CONFIG_CMD_RARP is not set
+CONFIG_CMD_NFS=y
+# CONFIG_CMD_MII is not set
+CONFIG_CMD_PING=y
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+# CONFIG_CMD_ETHSW is not set
+# CONFIG_CMD_PXE is not set
+# CONFIG_CMD_WOL is not set
+
+#
+# Misc commands
+#
+CONFIG_CMD_BSP=y
+# CONFIG_CMD_CACHE is not set
+# CONFIG_CMD_CONITRACE is not set
+# CONFIG_CMD_EXCEPTION is not set
+CONFIG_CMD_DATE=y
+# CONFIG_CMD_TIME is not set
+# CONFIG_CMD_GETTIME is not set
+# CONFIG_CMD_MISC is not set
+# CONFIG_MP is not set
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_SYSBOOT is not set
+# CONFIG_CMD_QFW is not set
+# CONFIG_CMD_TERMINAL is not set
+# CONFIG_CMD_UUID is not set
+
+#
+# TI specific command line interface
+#
+# CONFIG_CMD_DDR3 is not set
+
+#
+# Power commands
+#
+
+#
+# Security commands
+#
+# CONFIG_CMD_AES is not set
+# CONFIG_CMD_BLOB is not set
+# CONFIG_CMD_HASH is not set
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+# CONFIG_CMD_BTRFS is not set
+# CONFIG_CMD_EXT2 is not set
+# CONFIG_CMD_EXT4 is not set
+# CONFIG_CMD_FAT is not set
+# CONFIG_CMD_FS_GENERIC is not set
+# CONFIG_CMD_FS_UUID is not set
+# CONFIG_CMD_JFFS2 is not set
+CONFIG_CMD_MTDPARTS=y
+# CONFIG_CMD_MTDPARTS_SPREAD is not set
+# CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES is not set
+CONFIG_MTDIDS_DEFAULT="nand0=jz2440-0"
+CONFIG_MTDPARTS_DEFAULT="mtdparts=jz2440-0:128k@0(spl),256k(bootloader),128k(params),2m(kernel),-(root)"
+# CONFIG_CMD_REISER is not set
+# CONFIG_CMD_ZFS is not set
+
+#
+# Debug commands
+#
+# CONFIG_CMD_BEDBUG is not set
+# CONFIG_CMD_DIAG is not set
+# CONFIG_CMD_LOG is not set
+# CONFIG_CMD_TRACE is not set
+# CONFIG_CMD_UBI is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITIONS=y
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_DOS_PARTITION is not set
+# CONFIG_ISO_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_PARTITION_UUIDS is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+
+#
+# Device Tree Control
+#
+# CONFIG_OF_CONTROL is not set
+# CONFIG_MULTI_DTB_FIT is not set
+CONFIG_MKIMAGE_DTC_PATH="dtc"
+
+#
+# Environment
+#
+CONFIG_ENV_SUPPORT=y
+CONFIG_SAVEENV=y
+# CONFIG_ENV_IS_NOWHERE is not set
+# CONFIG_ENV_IS_IN_EEPROM is not set
+# CONFIG_ENV_IS_IN_FAT is not set
+# CONFIG_ENV_IS_IN_EXT4 is not set
+# CONFIG_ENV_IS_IN_FLASH is not set
+CONFIG_ENV_IS_IN_NAND=y
+# CONFIG_ENV_IS_IN_NVRAM is not set
+# CONFIG_ENV_IS_IN_ONENAND is not set
+# CONFIG_ENV_IS_IN_REMOTE is not set
+# CONFIG_SYS_REDUNDAND_ENVIRONMENT is not set
+# CONFIG_SYS_RELOC_GD_ENV_ADDR is not set
+# CONFIG_USE_DEFAULT_ENV_FILE is not set
+# CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG is not set
+# CONFIG_DELAY_ENVIRONMENT is not set
+# CONFIG_ENV_ACCESS_IGNORE_FORCE is not set
+CONFIG_NET=y
+# CONFIG_NET_RANDOM_ETHADDR is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_IP_DEFRAG is not set
+CONFIG_TFTP_BLOCKSIZE=1468
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_DM is not set
+CONFIG_DM_DEV_READ_INLINE=y
+# CONFIG_ACPIGEN is not set
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_SARADC_MESON is not set
+# CONFIG_SARADC_ROCKCHIP is not set
+# CONFIG_SATA is not set
+# CONFIG_SCSI_AHCI is not set
+
+#
+# SATA/SCSI device support
+#
+# CONFIG_DWC_AHSATA is not set
+# CONFIG_FSL_SATA is not set
+# CONFIG_MVSATA_IDE is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIL3114 is not set
+# CONFIG_AXI is not set
+CONFIG_HAVE_BLOCK_DEVICE=y
+# CONFIG_IDE is not set
+# CONFIG_BOOTCOUNT_LIMIT is not set
+
+#
+# Cache Controller drivers
+#
+# CONFIG_L2X0_CACHE is not set
+# CONFIG_NCORE_CACHE is not set
+
+#
+# Clock
+#
+# CONFIG_CLK_CCF is not set
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+# CONFIG_SYS_FSL_SEC_BE is not set
+# CONFIG_SYS_FSL_SEC_LE is not set
+
+#
+# Demo for driver model
+#
+# CONFIG_BOARD is not set
+
+#
+# DFU support
+#
+
+#
+# DMA Support
+#
+# CONFIG_TI_EDMA3 is not set
+
+#
+# Fastboot support
+#
+# CONFIG_UDP_FUNCTION_FASTBOOT is not set
+# CONFIG_FIRMWARE is not set
+# CONFIG_ZYNQMP_FIRMWARE is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_ALTERA is not set
+# CONFIG_FPGA_SOCFPGA is not set
+# CONFIG_FPGA_XILINX is not set
+
+#
+# GPIO Support
+#
+# CONFIG_DA8XX_GPIO is not set
+# CONFIG_MXC_GPIO is not set
+# CONFIG_MXS_GPIO is not set
+# CONFIG_CMD_PCA953X is not set
+# CONFIG_CMD_TCA642X is not set
+
+#
+# Hardware Spinlock Support
+#
+# CONFIG_DM_HWSPINLOCK is not set
+
+#
+# I2C support
+#
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_SYS_I2C_IMX_LPI2C is not set
+# CONFIG_SYS_I2C_MXC is not set
+# CONFIG_TEGRA_KEYBOARD is not set
+# CONFIG_TWL4030_INPUT is not set
+
+#
+# LED Support
+#
+# CONFIG_LED_STATUS is not set
+
+#
+# Mailbox Controller Support
+#
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_CROS_EC is not set
+# CONFIG_DS4510 is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_TWL4030_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+# CONFIG_FS_LOADER is not set
+
+#
+# MMC Host controller Support
+#
+# CONFIG_MMC is not set
+# CONFIG_MMC_BROKEN_CD is not set
+# CONFIG_FSL_ESDHC is not set
+# CONFIG_FSL_ESDHC_IMX is not set
+
+#
+# MTD Support
+#
+CONFIG_MTD=y
+CONFIG_MTD_NOR_FLASH=y
+# CONFIG_SYS_MTDPARTS_RUNTIME is not set
+CONFIG_FLASH_CFI_DRIVER=y
+# CONFIG_SYS_FLASH_USE_BUFFER_WRITE is not set
+# CONFIG_FLASH_CFI_MTD is not set
+# CONFIG_SYS_FLASH_PROTECTION is not set
+CONFIG_SYS_FLASH_CFI=y
+CONFIG_MTD_RAW_NAND=y
+# CONFIG_SYS_NAND_USE_FLASH_BBT is not set
+# CONFIG_NAND_ATMEL is not set
+# CONFIG_NAND_DAVINCI is not set
+# CONFIG_NAND_LPC32XX_SLC is not set
+# CONFIG_NAND_VF610_NFC is not set
+# CONFIG_NAND_PXA3XX is not set
+# CONFIG_NAND_ARASAN is not set
+# CONFIG_NAND_ZYNQ is not set
+
+#
+# Generic NAND options
+#
+
+#
+# SPI Flash Support
+#
+# CONFIG_SPI_FLASH is not set
+
+#
+# UBI support
+#
+# CONFIG_UBI_SILENCE_MSG is not set
+# CONFIG_MTD_UBI is not set
+# CONFIG_BITBANGMII is not set
+# CONFIG_MV88E6352_SWITCH is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_FSL_PFE is not set
+CONFIG_NETDEVICES=y
+# CONFIG_PHY_GIGE is not set
+# CONFIG_BCM_SF2_ETH is not set
+# CONFIG_E1000 is not set
+# CONFIG_ETH_DESIGNWARE is not set
+# CONFIG_ETHOC is not set
+# CONFIG_FMAN_ENET is not set
+# CONFIG_FTMAC100 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_RGMII is not set
+# CONFIG_MII is not set
+# CONFIG_RTL8139 is not set
+# CONFIG_RTL8169 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SUN7I_GMAC is not set
+# CONFIG_SH_ETHER is not set
+# CONFIG_DRIVER_TI_CPSW is not set
+# CONFIG_DRIVER_TI_EMAC is not set
+# CONFIG_DRIVER_TI_KEYSTONE_NET is not set
+# CONFIG_SYS_DPAA_QBMAN is not set
+# CONFIG_TSEC_ENET is not set
+# CONFIG_PCI is not set
+
+#
+# PCI Endpoint
+#
+# CONFIG_X86_PCH7 is not set
+# CONFIG_X86_PCH9 is not set
+
+#
+# PHY Subsystem
+#
+
+#
+# Rockchip PHY driver
+#
+# CONFIG_MVEBU_COMPHY_SUPPORT is not set
+
+#
+# Pin controllers
+#
+
+#
+# Power
+#
+# CONFIG_ACPI_PMC is not set
+# CONFIG_SPL_ACPI_PMC is not set
+# CONFIG_TPL_ACPI_PMC is not set
+
+#
+# Power Domain Support
+#
+# CONFIG_PMIC_AS3722 is not set
+# CONFIG_POWER_MC34VR500 is not set
+# CONFIG_POWER_MT6323 is not set
+# CONFIG_PWM_IMX is not set
+# CONFIG_PWM_SANDBOX is not set
+# CONFIG_U_QE is not set
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_RTC_ENABLE_32KHZ_OUTPUT is not set
+# CONFIG_RTC_RX8025 is not set
+# CONFIG_RTC_PL031 is not set
+# CONFIG_RTC_S35392A is not set
+# CONFIG_RTC_MC146818 is not set
+# CONFIG_RTC_M41T62 is not set
+# CONFIG_SCSI is not set
+
+#
+# Serial drivers
+#
+CONFIG_BAUDRATE=115200
+CONFIG_SPECIFY_CONSOLE_INDEX=y
+CONFIG_CONS_INDEX=1
+# CONFIG_ARM_DCC is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_MCFUART is not set
+# CONFIG_NULLDEV_SERIAL is not set
+# CONFIG_SYS_NS16550 is not set
+# CONFIG_NS16550_DYNAMIC is not set
+# CONFIG_PL010_SERIAL is not set
+# CONFIG_PL011_SERIAL is not set
+# CONFIG_PXA_SERIAL is not set
+# CONFIG_SMEM is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+# CONFIG_SOC_TI is not set
+# CONFIG_SPI is not set
+
+#
+# SPMI support
+#
+
+#
+# System reset device drivers
+#
+# CONFIG_SYSRESET_SYSCON is not set
+# CONFIG_SYSRESET_WATCHDOG is not set
+# CONFIG_SYSRESET_RESETCTL is not set
+# CONFIG_SYSRESET_MPC83XX is not set
+# CONFIG_OPTEE is not set
+# CONFIG_DM_THERMAL is not set
+
+#
+# Timer Support
+#
+
+#
+# TPM support
+#
+CONFIG_USB=y
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_XHCI_HCD is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_DWC2 is not set
+
+#
+# Legacy MUSB Support
+#
+# CONFIG_USB_MUSB_HCD is not set
+# CONFIG_USB_MUSB_UDC is not set
+
+#
+# MUSB Controller Driver
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_GADGET is not set
+# CONFIG_USB_MUSB_AM35X is not set
+# CONFIG_USB_MUSB_DSPS is not set
+# CONFIG_USB_MUSB_PIO_ONLY is not set
+
+#
+# USB Phy
+#
+# CONFIG_TWL4030_USB is not set
+# CONFIG_OMAP_USB_PHY is not set
+# CONFIG_ROCKCHIP_USB2_PHY is not set
+
+#
+# ULPI drivers
+#
+
+#
+# USB peripherals
+#
+# CONFIG_USB_STORAGE is not set
+# CONFIG_USB_KEYBOARD is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_USB_HOST_ETHER is not set
+
+#
+# UFS Host Controller Support
+#
+# CONFIG_TI_J721E_UFS is not set
+
+#
+# Graphics support
+#
+# CONFIG_SYS_WHITE_ON_BLACK is not set
+# CONFIG_NO_FB_CLEAR is not set
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_I2C_EDID is not set
+# CONFIG_VIDEO is not set
+# CONFIG_LCD is not set
+# CONFIG_VIDEO_SIMPLE is not set
+# CONFIG_VIDEO_DT_SIMPLEFB is not set
+
+#
+# VirtIO Drivers
+#
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# 1-Wire support
+#
+
+#
+# 1-wire EEPROM support
+#
+
+#
+# Watchdog Timer Support
+#
+# CONFIG_WATCHDOG is not set
+CONFIG_WATCHDOG_TIMEOUT_MSECS=60000
+# CONFIG_WATCHDOG_RESET_DISABLE is not set
+# CONFIG_IMX_WATCHDOG is not set
+# CONFIG_ULP_WATCHDOG is not set
+# CONFIG_DESIGNWARE_WATCHDOG is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+# CONFIG_FS_BTRFS is not set
+# CONFIG_FS_CBFS is not set
+# CONFIG_SPL_FS_CBFS is not set
+# CONFIG_FS_EXT4 is not set
+# CONFIG_FS_FAT is not set
+# CONFIG_FS_JFFS2 is not set
+# CONFIG_UBIFS_SILENCE_MSG is not set
+# CONFIG_FS_CRAMFS is not set
+# CONFIG_YAFFS2 is not set
+
+#
+# Library routines
+#
+# CONFIG_BCH is not set
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+# CONFIG_DYNAMIC_CRC_TABLE is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+CONFIG_PRINTF=y
+CONFIG_SPRINTF=y
+CONFIG_STRTO=y
+CONFIG_USE_PRIVATE_LIBGCC=y
+CONFIG_SYS_HZ=1000
+# CONFIG_PANIC_HANG is not set
+CONFIG_REGEX=y
+# CONFIG_SPL_TINY_MEMSET is not set
+# CONFIG_TPL_TINY_MEMSET is not set
+# CONFIG_BITREVERSE is not set
+# CONFIG_TRACE is not set
+# CONFIG_CMD_DHRYSTONE is not set
+
+#
+# Security support
+#
+# CONFIG_AES is not set
+# CONFIG_RSA is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+
+#
+# Android Verified Boot
+#
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+# CONFIG_MD5 is not set
+# CONFIG_SPL_MD5 is not set
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+# CONFIG_LZMA is not set
+# CONFIG_LZO is not set
+CONFIG_GZIP=y
+# CONFIG_BZIP2 is not set
+CONFIG_ZLIB=y
+# CONFIG_ZSTD is not set
+# CONFIG_SPL_LZ4 is not set
+# CONFIG_SPL_LZMA is not set
+# CONFIG_SPL_LZO is not set
+# CONFIG_SPL_GZIP is not set
+# CONFIG_SPL_ZSTD is not set
+# CONFIG_ERRNO_STR is not set
+# CONFIG_HEXDUMP is not set
+# CONFIG_OF_LIBFDT is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+# CONFIG_TPL_OF_LIBFDT is not set
+
+#
+# System tables
+#
+CONFIG_LIB_DATE=y
+# CONFIG_UNIT_TEST is not set
diff -urN u-boot-2020.07/configs/jz2440_defconfig u-boot_2020.07_100ask/configs/jz2440_defconfig
--- u-boot-2020.07/configs/jz2440_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/configs/jz2440_defconfig	2020-08-03 18:15:02.951103809 +0800
@@ -0,0 +1,35 @@
+CONFIG_ARM=y
+CONFIG_SYS_TEXT_BASE=0x33F00000
+CONFIG_TARGET_JZ2440=y
+CONFIG_BOOTDELAY=3
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Jz2440 # "
+CONFIG_CMD_PING=y
+CONFIG_USB=y
+
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttySAC0 root=/dev/mtdblock4"
+CONFIG_BOOTCOMMAND="nand read 30000000 kernel;bootm 30000000"
+
+CONFIG_MTD=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_MTDIDS_DEFAULT="nand0=jz2440-0"
+CONFIG_MTDPARTS_DEFAULT="mtdparts=jz2440-0:128k@0(spl),256k(bootloader),128k(params),2m(kernel),-(root)"
+
+CONFIG_ENV_IS_IN_NAND=y
+CONFIG_ENV_OFFSET=0x60000
+CONFIG_ENV_SIZE=0x20000
+CONFIG_ENV_RANGE=0x20000
+
+CONFIG_CMD_BSP=y
+CONFIG_CMD_DATE=y
+CONFIG_CMD_NAND=y
+CONFIG_CMD_REGINFO=y
+CONFIG_CMDLINE_EDITING=y
+
+CONFIG_NR_DRAM_BANKS=1
+
+CONFIG_MTD_NOR_FLASH=y
+CONFIG_SYS_FLASH_CFI=y
+CONFIG_FLASH_CFI_DRIVER=y
diff -urN u-boot-2020.07/drivers/gpio/Makefile u-boot_2020.07_100ask/drivers/gpio/Makefile
--- u-boot-2020.07/drivers/gpio/Makefile	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/drivers/gpio/Makefile	2020-08-03 18:15:02.975104027 +0800
@@ -65,3 +65,6 @@
 obj-$(CONFIG_MT7621_GPIO)	+= mt7621_gpio.o
 obj-$(CONFIG_MSCC_SGPIO)	+= mscc_sgpio.o
 obj-$(CONFIG_SIFIVE_GPIO)	+= sifive-gpio.o
+
+#DaQui Modified
+obj-$(CONFIG_S3C2440_GPIO)      += s3c2440_gpio.o
diff -urN u-boot-2020.07/drivers/gpio/s3c2440_gpio.c u-boot_2020.07_100ask/drivers/gpio/s3c2440_gpio.c
--- u-boot-2020.07/drivers/gpio/s3c2440_gpio.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/drivers/gpio/s3c2440_gpio.c	2020-08-03 18:15:02.975104027 +0800
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2012
+ * Gabriel Huau <contact@huau-gabriel.fr>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <asm/arch/s3c2440.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <errno.h>
+
+#define GPIO_INPUT  0x0
+#define GPIO_OUTPUT 0x1
+
+#define S3C_GPIO_CON	0x0
+#define S3C_GPIO_DAT	0x4
+
+static uint32_t s3c_gpio_get_bank_addr(unsigned gpio)
+{
+	/* There is up to 16 pins per bank, one bank is 0x10 big. */
+	uint32_t addr = gpio & ~0xf;
+
+	if (addr >= 0x80 && addr != 0xd0) {	/* Wrong GPIO bank. */
+		printf("Invalid GPIO bank (bank %02x)\n", addr);
+		return 0xffffffff;
+	}
+
+	return addr | S3C24X0_GPIO_BASE;
+}
+
+int gpio_set_value(unsigned gpio, int value)
+{
+	uint32_t addr = s3c_gpio_get_bank_addr(gpio);
+
+	if (addr == 0xffffffff)
+		return -EINVAL;
+
+	if (value)
+		setbits_le32(addr | S3C_GPIO_DAT, 1 << (gpio & 0xf));
+	else
+		clrbits_le32(addr | S3C_GPIO_DAT, 1 << (gpio & 0xf));
+
+	return 0;
+}
+
+int gpio_get_value(unsigned gpio)
+{
+	uint32_t addr = s3c_gpio_get_bank_addr(gpio);
+
+	if (addr == 0xffffffff)
+		return -EINVAL;
+
+	return !!(readl(addr | S3C_GPIO_DAT) & (1 << (gpio & 0xf)));
+}
+
+int gpio_request(unsigned gpio, const char *label)
+{
+	return 0;
+}
+
+int gpio_free(unsigned gpio)
+{
+	return 0;
+}
+
+static int s3c_gpio_direction(unsigned gpio, uint8_t dir)
+{
+	uint32_t addr = s3c_gpio_get_bank_addr(gpio);
+	const uint32_t mask = 0x3 << ((gpio & 0xf) << 1);
+	const uint32_t dirm = dir << ((gpio & 0xf) << 1);
+
+	if (addr == 0xffffffff)
+		return -EINVAL;
+
+	clrsetbits_le32(addr | S3C_GPIO_CON, mask, dirm);
+	return 0;
+}
+
+int gpio_direction_input(unsigned gpio)
+{
+	return s3c_gpio_direction(gpio, GPIO_INPUT);
+}
+
+int gpio_direction_output(unsigned gpio, int value)
+{
+	return s3c_gpio_direction(gpio, GPIO_OUTPUT);
+}
diff -urN u-boot-2020.07/drivers/mtd/jedec_flash.c u-boot_2020.07_100ask/drivers/mtd/jedec_flash.c
--- u-boot-2020.07/drivers/mtd/jedec_flash.c	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/drivers/mtd/jedec_flash.c	2020-08-03 18:15:02.983104100 +0800
@@ -401,6 +401,26 @@
 		}
 	},
 #endif
+        /* DaQui modified MXMT29LV160DB */
+#ifdef CONFIG_SYS_FLASH_LEGACY_2Mx8
+        {
+                .mfr_id         = (u16)MX_MANUFACT,
+                .dev_id         = 0X2249,
+                .name           = "MXIC MT29LV160DB",
+                .uaddr          = {
+                 [1] = MTD_UADDR_0x0555_0x02AA
+                },
+                .DevSize        = SIZE_2MiB,
+                .CmdSet         = P_ID_AMD_STD,
+                .NumEraseRegions= 4,
+                .regions        = {
+                        ERASEINFO(16*1024, 1),
+                        ERASEINFO(8*1024, 2),
+                        ERASEINFO(32*1024, 1),
+                        ERASEINFO(64*1024, 31),
+                }
+        },
+#endif
 };
 
 static inline void fill_info(flash_info_t *info, const struct amd_flash_info *jedec_entry, ulong base)
diff -urN u-boot-2020.07/drivers/mtd/nand/raw/Makefile u-boot_2020.07_100ask/drivers/mtd/nand/raw/Makefile
--- u-boot-2020.07/drivers/mtd/nand/raw/Makefile	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/drivers/mtd/nand/raw/Makefile	2020-08-03 18:15:02.983104100 +0800
@@ -68,6 +68,9 @@
 obj-$(CONFIG_NAND_ZYNQ) += zynq_nand.o
 obj-$(CONFIG_NAND_STM32_FMC2) += stm32_fmc2_nand.o
 
+# DaQui Modified
+obj-$(CONFIG_NAND_S3C2440) += s3c2440_nand.o
+
 else  # minimal SPL drivers
 
 obj-$(CONFIG_NAND_FSL_ELBC) += fsl_elbc_spl.o
diff -urN u-boot-2020.07/drivers/mtd/nand/raw/nand_util.c u-boot_2020.07_100ask/drivers/mtd/nand/raw/nand_util.c
--- u-boot-2020.07/drivers/mtd/nand/raw/nand_util.c	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/drivers/mtd/nand/raw/nand_util.c	2020-08-03 18:15:02.983104100 +0800
@@ -582,9 +582,27 @@
 
 	if (actual)
 		*actual = 0;
-
-	blocksize = mtd->erasesize;
-
+	
+	 /*DaQui Modified*/
+#ifdef CONFIG_CMD_NAND_YAFFS /*DaQui modified*/
+	if (flags & WITH_YAFFS_OOB) {
+		if (flags & ~WITH_YAFFS_OOB)
+				return -EINVAL;
+
+		int pages;
+		pages = mtd->erasesize / mtd->writesize;
+			blocksize = (pages * mtd->oobsize) + mtd->erasesize;
+		if (*length % (mtd->writesize + mtd->oobsize)) {
+			printf ("Attempt to write incomplete page"
+									" in yaffs mode\n");
+			return -EINVAL;
+		}
+	}
+	else
+#endif
+	{
+		blocksize = mtd->erasesize;
+	}
 	/*
 	 * nand_write() handles unaligned, partial page writes.
 	 *
@@ -619,7 +637,7 @@
 		return -EFBIG;
 	}
 
-	if (!need_skip && !(flags & WITH_DROP_FFS)) {
+	if (!need_skip && !(flags & WITH_DROP_FFS) &&!(flags & WITH_YAFFS_OOB)) {
 		rval = nand_write(mtd, offset, length, buffer);
 
 		if ((flags & WITH_WR_VERIFY) && !rval)
@@ -652,33 +670,63 @@
 		else
 			write_size = blocksize - block_offset;
 
-		truncated_write_size = write_size;
+#ifdef CONFIG_CMD_NAND_YAFFS /*DaQui modified*/
+		if (flags & WITH_YAFFS_OOB) {
+			int page, pages;
+			size_t pagesize = mtd->writesize;
+			size_t pagesize_oob = pagesize + mtd->oobsize;
+			struct mtd_oob_ops ops;
+
+			ops.len = pagesize;
+			ops.ooblen = mtd->oobsize;
+			ops.mode = MTD_OPS_RAW;
+			ops.ooboffs = 0;
+
+			pages = write_size / pagesize_oob;
+			for (page = 0; page < pages; page++) {
+				WATCHDOG_RESET();
+
+				ops.datbuf = p_buffer;
+				ops.oobbuf = ops.datbuf + pagesize;
+
+				rval = mtd->_write_oob(mtd, offset, &ops);
+				if (rval)  /* weidongshan@qq.com */
+								break;
+
+				offset += pagesize;
+				p_buffer += pagesize_oob;
+			}
+		}
+		else
+#endif
+		{
+			truncated_write_size = write_size;
 #ifdef CONFIG_CMD_NAND_TRIMFFS
-		if (flags & WITH_DROP_FFS)
-			truncated_write_size = drop_ffs(mtd, p_buffer,
-					&write_size);
+			if (flags & WITH_DROP_FFS)
+				truncated_write_size = drop_ffs(mtd, p_buffer,
+						&write_size);
 #endif
 
-		rval = nand_write(mtd, offset, &truncated_write_size,
-				p_buffer);
-
-		if ((flags & WITH_WR_VERIFY) && !rval)
-			rval = nand_verify(mtd, offset,
-				truncated_write_size, p_buffer);
+			rval = nand_write(mtd, offset, &truncated_write_size,
+					p_buffer);
 
-		offset += write_size;
-		p_buffer += write_size;
+			if ((flags & WITH_WR_VERIFY) && !rval)
+				rval = nand_verify(mtd, offset,
+					truncated_write_size, p_buffer);
+
+			offset += write_size;
+			p_buffer += write_size;
+			}
+			if (rval != 0) {
+				printf("NAND write to offset %llx failed %d\n",
+					offset, rval);
+				*length -= left_to_write;
+				return rval;
+			}
 
-		if (rval != 0) {
-			printf("NAND write to offset %llx failed %d\n",
-				offset, rval);
-			*length -= left_to_write;
-			return rval;
+			left_to_write -= write_size;
 		}
 
-		left_to_write -= write_size;
-	}
-
 	return 0;
 }
 
diff -urN u-boot-2020.07/drivers/mtd/nand/raw/s3c2440_nand.c u-boot_2020.07_100ask/drivers/mtd/nand/raw/s3c2440_nand.c
--- u-boot-2020.07/drivers/mtd/nand/raw/s3c2440_nand.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/drivers/mtd/nand/raw/s3c2440_nand.c	2020-08-03 18:15:02.983104100 +0800
@@ -0,0 +1,187 @@
+/*
+ * (C) Copyright 2006 OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+ 
+/* DaQui Modified */
+#include <common.h>
+#include <linux/bug.h>
+
+#include <nand.h>
+#include <asm/arch-s3c24x0/s3c24x0_cpu.h>
+#include <asm/io.h>
+
+#define S3C2440_NFCONF_EN          (1<<15)
+#define S3C2440_NFCONF_512BYTE     (1<<14)
+#define S3C2440_NFCONF_4STEP       (1<<13)
+#define S3C2440_NFCONF_INITECC     (1<<12)
+#define S3C2440_NFCONF_nFCE        (1<<11)
+#define S3C2440_NFCONF_TACLS(x)    ((x)<<8)
+#define S3C2440_NFCONF_TWRPH0(x)   ((x)<<4)
+#define S3C2440_NFCONF_TWRPH1(x)   ((x)<<0)
+
+#define S3C2440_ADDR_NALE 4
+#define S3C2440_ADDR_NCLE 8
+
+#ifdef CONFIG_NAND_SPL
+
+/* in the early stage of NAND flash booting, printf() is not available */
+#define printf(fmt, args...)
+
+static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd_to_nand(mtd);
+
+	for (i = 0; i < len; i++)
+		buf[i] = readb(this->IO_ADDR_R);
+}
+#endif
+
+static void s3c24x0_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	   struct s3c24x0_nand *nand = s3c24x0_get_base_nand();
+
+		if (ctrl & NAND_CLE)
+		{
+			//write command
+			writeb(cmd, &nand->nfcmd);
+		}
+		else if(ctrl & NAND_ALE)
+		{
+			//write address
+			writeb(cmd, &nand->nfaddr);
+		}
+}
+
+static int s3c24x0_dev_ready(struct mtd_info *mtd)
+{
+	struct s3c24x0_nand *nand = s3c24x0_get_base_nand();
+	debug("dev_ready\n");
+	return readl(&nand->nfstat) & 0x01;
+}
+
+#ifdef CONFIG_S3C2440_NAND_HWECC
+void s3c24x0_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	struct s3c24x0_nand *nand = s3c24x0_get_base_nand();
+	debug("s3c24x0_nand_enable_hwecc(%p, %d)\n", mtd, mode);
+	writel(readl(&nand->nfconf) | S3C2440_NFCONF_INITECC, &nand->nfconf);
+}
+
+static int s3c24x0_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				      u_char *ecc_code)
+{
+	struct s3c24x0_nand *nand = s3c24x0_get_base_nand();
+	ecc_code[0] = readb(&nand->nfecc);
+	ecc_code[1] = readb(&nand->nfecc + 1);
+	ecc_code[2] = readb(&nand->nfecc + 2);
+	debug("s3c24x0_nand_calculate_hwecc(%p,): 0x%02x 0x%02x 0x%02x\n",
+	      mtd , ecc_code[0], ecc_code[1], ecc_code[2]);
+
+	return 0;
+}
+
+static int s3c24x0_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+				     u_char *read_ecc, u_char *calc_ecc)
+{
+	if (read_ecc[0] == calc_ecc[0] &&
+	    read_ecc[1] == calc_ecc[1] &&
+	    read_ecc[2] == calc_ecc[2])
+		return 0;
+
+	printf("s3c24x0_nand_correct_data: not implemented\n");
+	return -EBADMSG;
+}
+#endif
+
+static void s3c2440_nand_select(struct mtd_info *mtd, int chipnr)
+{
+        struct s3c24x0_nand *nand = s3c24x0_get_base_nand();
+
+        switch (chipnr) {
+        case -1: 
+                nand->nfcont |= (1<<1);
+                break;
+        case 0:
+                nand->nfcont &= ~(1<<1);
+                break;
+        default:
+                BUG();
+        }
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	u_int32_t cfg;
+	u_int8_t tacls, twrph0, twrph1;
+	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
+	struct s3c24x0_nand *nand_reg = s3c24x0_get_base_nand();
+
+	debug("board_nand_init()\n");
+
+	writel(readl(&clk_power->clkcon) | (1 << 4), &clk_power->clkcon);
+
+	/* initialize hardware */
+#if defined(CONFIG_S3C24XX_CUSTOM_NAND_TIMING)
+	tacls  = CONFIG_S3C24XX_TACLS;
+	twrph0 = CONFIG_S3C24XX_TWRPH0;
+	twrph1 =  CONFIG_S3C24XX_TWRPH1;
+#else
+	tacls = 4;
+	twrph0 = 8;
+	twrph1 = 8;
+#endif
+
+#if 0
+	cfg = S3C2440_NFCONF_EN;
+	cfg |= S3C2440_NFCONF_TACLS(tacls - 1);
+	cfg |= S3C2440_NFCONF_TWRPH0(twrph0 - 1);
+	cfg |= S3C2440_NFCONF_TWRPH1(twrph1 - 1);
+	writel(cfg, &nand_reg->nfconf);
+#endif
+	
+	cfg = ((tacls-1)<<12)|((twrph0-1)<<8)|((twrph1-1)<<4);
+			writel(cfg, &nand_reg->nfconf);
+			
+	writel((1<<4)|(1<<1)|(1<<0), &nand_reg->nfcont);
+			
+	/* initialize nand_chip data structure */
+	nand->IO_ADDR_R = (void *)&nand_reg->nfdata;
+	nand->IO_ADDR_W = (void *)&nand_reg->nfdata;
+
+	nand->select_chip = s3c2440_nand_select;
+
+	/* read_buf and write_buf are default */
+	/* read_byte and write_byte are default */
+#ifdef CONFIG_NAND_SPL
+	nand->read_buf = nand_read_buf;
+#endif
+
+	/* hwcontrol always must be implemented */
+	nand->cmd_ctrl = s3c24x0_hwcontrol;
+
+	nand->dev_ready = s3c24x0_dev_ready;
+
+#ifdef CONFIG_S3C2440_NAND_HWECC
+	nand->ecc.hwctl = s3c24x0_nand_enable_hwecc;
+	nand->ecc.calculate = s3c24x0_nand_calculate_ecc;
+	nand->ecc.correct = s3c24x0_nand_correct_data;
+	nand->ecc.mode = NAND_ECC_HW;
+	nand->ecc.size = CONFIG_SYS_NAND_ECCSIZE;
+	nand->ecc.bytes = CONFIG_SYS_NAND_ECCBYTES;
+	nand->ecc.strength = 1;
+#else
+	nand->ecc.mode = NAND_ECC_SOFT;
+#endif
+
+#ifdef CONFIG_S3C2440_NAND_BBT
+	nand->bbt_options |= NAND_BBT_USE_FLASH;
+#endif
+
+	debug("end of nand_init\n");
+
+	return 0;
+}
diff -urN u-boot-2020.07/drivers/mtd/nand/s3c2440_nand.c u-boot_2020.07_100ask/drivers/mtd/nand/s3c2440_nand.c
--- u-boot-2020.07/drivers/mtd/nand/s3c2440_nand.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/drivers/mtd/nand/s3c2440_nand.c	2020-08-03 18:15:02.983104100 +0800
@@ -0,0 +1,186 @@
+/*
+ * (C) Copyright 2006 OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+ 
+/* DaQui Modified */
+#include <common.h>
+
+#include <nand.h>
+#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/io.h>
+
+#define S3C2440_NFCONF_EN          (1<<15)
+#define S3C2440_NFCONF_512BYTE     (1<<14)
+#define S3C2440_NFCONF_4STEP       (1<<13)
+#define S3C2440_NFCONF_INITECC     (1<<12)
+#define S3C2440_NFCONF_nFCE        (1<<11)
+#define S3C2440_NFCONF_TACLS(x)    ((x)<<8)
+#define S3C2440_NFCONF_TWRPH0(x)   ((x)<<4)
+#define S3C2440_NFCONF_TWRPH1(x)   ((x)<<0)
+
+#define S3C2440_ADDR_NALE 4
+#define S3C2440_ADDR_NCLE 8
+
+#ifdef CONFIG_NAND_SPL
+
+/* in the early stage of NAND flash booting, printf() is not available */
+#define printf(fmt, args...)
+
+static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd_to_nand(mtd);
+
+	for (i = 0; i < len; i++)
+		buf[i] = readb(this->IO_ADDR_R);
+}
+#endif
+
+static void s3c24x0_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	   struct s3c24x0_nand *nand = s3c24x0_get_base_nand();
+
+		if (ctrl & NAND_CLE)
+		{
+			//write command
+			writeb(cmd, &nand->nfcmd);
+		}
+		else if(ctrl & NAND_ALE)
+		{
+			//write address
+			writeb(cmd, &nand->nfaddr);
+		}
+}
+
+static int s3c24x0_dev_ready(struct mtd_info *mtd)
+{
+	struct s3c24x0_nand *nand = s3c24x0_get_base_nand();
+	debug("dev_ready\n");
+	return readl(&nand->nfstat) & 0x01;
+}
+
+#ifdef CONFIG_S3C2440_NAND_HWECC
+void s3c24x0_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	struct s3c24x0_nand *nand = s3c24x0_get_base_nand();
+	debug("s3c24x0_nand_enable_hwecc(%p, %d)\n", mtd, mode);
+	writel(readl(&nand->nfconf) | S3C2440_NFCONF_INITECC, &nand->nfconf);
+}
+
+static int s3c24x0_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				      u_char *ecc_code)
+{
+	struct s3c24x0_nand *nand = s3c24x0_get_base_nand();
+	ecc_code[0] = readb(&nand->nfecc);
+	ecc_code[1] = readb(&nand->nfecc + 1);
+	ecc_code[2] = readb(&nand->nfecc + 2);
+	debug("s3c24x0_nand_calculate_hwecc(%p,): 0x%02x 0x%02x 0x%02x\n",
+	      mtd , ecc_code[0], ecc_code[1], ecc_code[2]);
+
+	return 0;
+}
+
+static int s3c24x0_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+				     u_char *read_ecc, u_char *calc_ecc)
+{
+	if (read_ecc[0] == calc_ecc[0] &&
+	    read_ecc[1] == calc_ecc[1] &&
+	    read_ecc[2] == calc_ecc[2])
+		return 0;
+
+	printf("s3c24x0_nand_correct_data: not implemented\n");
+	return -EBADMSG;
+}
+#endif
+
+static void s3c2440_nand_select(struct mtd_info *mtd, int chipnr)
+{
+        struct s3c24x0_nand *nand = s3c24x0_get_base_nand();
+
+        switch (chipnr) {
+        case -1: 
+                nand->nfcont |= (1<<1);
+                break;
+        case 0:
+                nand->nfcont &= ~(1<<1);
+                break;
+        default:
+                BUG();
+        }
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	u_int32_t cfg;
+	u_int8_t tacls, twrph0, twrph1;
+	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
+	struct s3c24x0_nand *nand_reg = s3c24x0_get_base_nand();
+
+	debug("board_nand_init()\n");
+
+	writel(readl(&clk_power->clkcon) | (1 << 4), &clk_power->clkcon);
+
+	/* initialize hardware */
+#if defined(CONFIG_S3C24XX_CUSTOM_NAND_TIMING)
+	tacls  = CONFIG_S3C24XX_TACLS;
+	twrph0 = CONFIG_S3C24XX_TWRPH0;
+	twrph1 =  CONFIG_S3C24XX_TWRPH1;
+#else
+	tacls = 4;
+	twrph0 = 8;
+	twrph1 = 8;
+#endif
+
+#if 0
+	cfg = S3C2440_NFCONF_EN;
+	cfg |= S3C2440_NFCONF_TACLS(tacls - 1);
+	cfg |= S3C2440_NFCONF_TWRPH0(twrph0 - 1);
+	cfg |= S3C2440_NFCONF_TWRPH1(twrph1 - 1);
+	writel(cfg, &nand_reg->nfconf);
+#endif
+	
+	cfg = ((tacls-1)<<12)|((twrph0-1)<<8)|((twrph1-1)<<4);
+			writel(cfg, &nand_reg->nfconf);
+			
+	writel((1<<4)|(1<<1)|(1<<0), &nand_reg->nfcont);
+			
+	/* initialize nand_chip data structure */
+	nand->IO_ADDR_R = (void *)&nand_reg->nfdata;
+	nand->IO_ADDR_W = (void *)&nand_reg->nfdata;
+
+	nand->select_chip = s3c2440_nand_select;
+
+	/* read_buf and write_buf are default */
+	/* read_byte and write_byte are default */
+#ifdef CONFIG_NAND_SPL
+	nand->read_buf = nand_read_buf;
+#endif
+
+	/* hwcontrol always must be implemented */
+	nand->cmd_ctrl = s3c24x0_hwcontrol;
+
+	nand->dev_ready = s3c24x0_dev_ready;
+
+#ifdef CONFIG_S3C2440_NAND_HWECC
+	nand->ecc.hwctl = s3c24x0_nand_enable_hwecc;
+	nand->ecc.calculate = s3c24x0_nand_calculate_ecc;
+	nand->ecc.correct = s3c24x0_nand_correct_data;
+	nand->ecc.mode = NAND_ECC_HW;
+	nand->ecc.size = CONFIG_SYS_NAND_ECCSIZE;
+	nand->ecc.bytes = CONFIG_SYS_NAND_ECCBYTES;
+	nand->ecc.strength = 1;
+#else
+	nand->ecc.mode = NAND_ECC_SOFT;
+#endif
+
+#ifdef CONFIG_S3C2440_NAND_BBT
+	nand->bbt_options |= NAND_BBT_USE_FLASH;
+#endif
+
+	debug("end of nand_init\n");
+
+	return 0;
+}
diff -urN u-boot-2020.07/drivers/serial/Makefile u-boot_2020.07_100ask/drivers/serial/Makefile
--- u-boot-2020.07/drivers/serial/Makefile	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/drivers/serial/Makefile	2020-08-03 18:15:03.003104283 +0800
@@ -49,6 +49,9 @@
 ifdef CONFIG_SPL_BUILD
 obj-$(CONFIG_ROCKCHIP_SERIAL) += serial_rockchip.o
 endif
+#DaQui Modified
+obj-$(CONFIG_S3C24X0_SERIAL) += serial_s3c24x0.o
+
 obj-$(CONFIG_XILINX_UARTLITE) += serial_xuartlite.o
 obj-$(CONFIG_SANDBOX_SERIAL) += sandbox.o
 obj-$(CONFIG_SCIF_CONSOLE) += serial_sh.o
diff -urN u-boot-2020.07/drivers/serial/serial_s3c24x0.c u-boot_2020.07_100ask/drivers/serial/serial_s3c24x0.c
--- u-boot-2020.07/drivers/serial/serial_s3c24x0.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/drivers/serial/serial_s3c24x0.c	2020-08-03 18:15:03.003104283 +0800
@@ -0,0 +1,210 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <linux/compiler.h>
+#include <asm/arch/s3c24x0_cpu.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern ulong get_PCLK(void);
+
+#ifdef CONFIG_SERIAL1
+#define UART_NR	S3C24X0_UART0
+
+#elif defined(CONFIG_SERIAL2)
+#define UART_NR	S3C24X0_UART1
+
+#elif defined(CONFIG_SERIAL3)
+#define UART_NR	S3C24X0_UART2
+
+#else
+#error "Bad: you didn't configure serial ..."
+#endif
+
+#include <asm/io.h>
+#include <serial.h>
+
+/* Multi serial device functions */
+#define DECLARE_S3C_SERIAL_FUNCTIONS(port) \
+	int s3serial##port##_init(void) \
+	{ \
+		return serial_init_dev(port); \
+	} \
+	void s3serial##port##_setbrg(void) \
+	{ \
+		serial_setbrg_dev(port); \
+	} \
+	int s3serial##port##_getc(void) \
+	{ \
+		return serial_getc_dev(port); \
+	} \
+	int s3serial##port##_tstc(void) \
+	{ \
+		return serial_tstc_dev(port); \
+	} \
+	void s3serial##port##_putc(const char c) \
+	{ \
+		serial_putc_dev(port, c); \
+	} \
+	void s3serial##port##_puts(const char *s) \
+	{ \
+		serial_puts_dev(port, s); \
+	}
+
+#define INIT_S3C_SERIAL_STRUCTURE(port, __name) {	\
+	.name	= __name,				\
+	.start	= s3serial##port##_init,		\
+	.stop	= NULL,					\
+	.setbrg	= s3serial##port##_setbrg,		\
+	.getc	= s3serial##port##_getc,		\
+	.tstc	= s3serial##port##_tstc,		\
+	.putc	= s3serial##port##_putc,		\
+	.puts	= s3serial##port##_puts,		\
+}
+
+static void _serial_setbrg(const int dev_index)
+{
+	struct s3c24x0_uart *uart = s3c24x0_get_base_uart(dev_index);
+	unsigned int reg = 0;
+	int i;
+
+	/* value is calculated so : (int)(PCLK/16./baudrate) -1 */
+	reg = get_PCLK() / (16 * gd->baudrate) - 1;
+
+	writel(reg, &uart->ubrdiv);
+	for (i = 0; i < 100; i++)
+		/* Delay */ ;
+}
+
+static inline void serial_setbrg_dev(unsigned int dev_index)
+{
+	_serial_setbrg(dev_index);
+}
+
+/* Initialise the serial port. The settings are always 8 data bits, no parity,
+ * 1 stop bit, no start bits.
+ */
+static int serial_init_dev(const int dev_index)
+{
+	struct s3c24x0_uart *uart = s3c24x0_get_base_uart(dev_index);
+
+	/* FIFO enable, Tx/Rx FIFO clear */
+	writel(0x07, &uart->ufcon);
+	writel(0x0, &uart->umcon);
+
+	/* Normal,No parity,1 stop,8 bit */
+	writel(0x3, &uart->ulcon);
+	/*
+	 * tx=level,rx=edge,disable timeout int.,enable rx error int.,
+	 * normal,interrupt or polling
+	 */
+	writel(0x245, &uart->ucon);
+
+	_serial_setbrg(dev_index);
+
+	return (0);
+}
+
+/*
+ * Read a single byte from the serial port. Returns 1 on success, 0
+ * otherwise. When the function is succesfull, the character read is
+ * written into its argument c.
+ */
+static int _serial_getc(const int dev_index)
+{
+	struct s3c24x0_uart *uart = s3c24x0_get_base_uart(dev_index);
+
+	while (!(readl(&uart->utrstat) & 0x1))
+		/* wait for character to arrive */ ;
+
+	return readb(&uart->urxh) & 0xff;
+}
+
+static inline int serial_getc_dev(unsigned int dev_index)
+{
+	return _serial_getc(dev_index);
+}
+
+/*
+ * Output a single byte to the serial port.
+ */
+static void _serial_putc(const char c, const int dev_index)
+{
+	struct s3c24x0_uart *uart = s3c24x0_get_base_uart(dev_index);
+
+	/* If \n, also do \r */
+	if (c == '\n')
+		serial_putc('\r');
+
+	while (!(readl(&uart->utrstat) & 0x2))
+		/* wait for room in the tx FIFO */ ;
+
+	writeb(c, &uart->utxh);
+}
+
+static inline void serial_putc_dev(unsigned int dev_index, const char c)
+{
+	_serial_putc(c, dev_index);
+}
+
+/*
+ * Test whether a character is in the RX buffer
+ */
+static int _serial_tstc(const int dev_index)
+{
+	struct s3c24x0_uart *uart = s3c24x0_get_base_uart(dev_index);
+
+	return readl(&uart->utrstat) & 0x1;
+}
+
+static inline int serial_tstc_dev(unsigned int dev_index)
+{
+	return _serial_tstc(dev_index);
+}
+
+static void _serial_puts(const char *s, const int dev_index)
+{
+	while (*s) {
+		_serial_putc(*s++, dev_index);
+	}
+}
+
+static inline void serial_puts_dev(int dev_index, const char *s)
+{
+	_serial_puts(s, dev_index);
+}
+
+DECLARE_S3C_SERIAL_FUNCTIONS(0);
+struct serial_device s3c24xx_serial0_device =
+INIT_S3C_SERIAL_STRUCTURE(0, "s3ser0");
+DECLARE_S3C_SERIAL_FUNCTIONS(1);
+struct serial_device s3c24xx_serial1_device =
+INIT_S3C_SERIAL_STRUCTURE(1, "s3ser1");
+DECLARE_S3C_SERIAL_FUNCTIONS(2);
+struct serial_device s3c24xx_serial2_device =
+INIT_S3C_SERIAL_STRUCTURE(2, "s3ser2");
+
+__weak struct serial_device *default_serial_console(void)
+{
+#if defined(CONFIG_SERIAL1)
+	return &s3c24xx_serial0_device;
+#elif defined(CONFIG_SERIAL2)
+	return &s3c24xx_serial1_device;
+#elif defined(CONFIG_SERIAL3)
+	return &s3c24xx_serial2_device;
+#else
+#error "CONFIG_SERIAL? missing."
+#endif
+}
+
+void s3c24xx_serial_initialize(void)
+{
+	serial_register(&s3c24xx_serial0_device);
+	serial_register(&s3c24xx_serial1_device);
+	serial_register(&s3c24xx_serial2_device);
+}
diff -urN u-boot-2020.07/drivers/usb/host/Makefile u-boot_2020.07_100ask/drivers/usb/host/Makefile
--- u-boot-2020.07/drivers/usb/host/Makefile	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/drivers/usb/host/Makefile	2020-08-03 18:15:03.011104354 +0800
@@ -18,6 +18,8 @@
 obj-$(CONFIG_USB_OHCI_LPC32XX) += ohci-lpc32xx.o
 obj-$(CONFIG_USB_OHCI_PCI) += ohci-pci.o
 obj-$(CONFIG_USB_OHCI_GENERIC) += ohci-generic.o
+# DaQui Modified
+obj-$(CONFIG_USB_OHCI_S3C24XX) += ohci-s3c24xx.o
 
 # echi
 obj-$(CONFIG_USB_EHCI_HCD) += ehci-hcd.o
diff -urN u-boot-2020.07/drivers/usb/host/ohci-s3c24xx.c u-boot_2020.07_100ask/drivers/usb/host/ohci-s3c24xx.c
--- u-boot-2020.07/drivers/usb/host/ohci-s3c24xx.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/drivers/usb/host/ohci-s3c24xx.c	2020-08-03 18:15:03.011104354 +0800
@@ -0,0 +1,1690 @@
+/*
+ * URB OHCI HCD (Host Controller Driver) for USB on the S3C2400.
+ *
+ * (C) Copyright 2003
+ * Gary Jennejohn, DENX Software Engineering <garyj@denx.de>
+ *
+ * Note: Much of this code has been derived from Linux 2.4
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2002 David Brownell
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+/*
+ * IMPORTANT NOTES
+ * 1 - this driver is intended for use with USB Mass Storage Devices
+ *     (BBB) ONLY. There is NO support for Interrupt or Isochronous pipes!
+ */
+
+#include <common.h>
+#include <linux/delay.h> /*DaQui Modified*/
+/* #include <pci.h> no PCI on the S3C24X0 */
+
+#if defined(CONFIG_USB_OHCI) && defined(CONFIG_S3C24X0)
+
+#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/io.h>
+#include <malloc.h>
+#include <usb.h>
+#include "ohci-s3c24xx.h"
+
+#define OHCI_USE_NPS		/* force NoPowerSwitching mode */
+#undef OHCI_VERBOSE_DEBUG	/* not always helpful */
+
+
+/* For initializing controller (mask in an HCFS mode too) */
+#define	OHCI_CONTROL_INIT \
+	(OHCI_CTRL_CBSR & 0x3) | OHCI_CTRL_IE | OHCI_CTRL_PLE
+
+#undef DEBUG
+#ifdef DEBUG
+#define dbg(format, arg...) printf("DEBUG: " format "\n", ## arg)
+#else
+#define dbg(format, arg...) do {} while(0)
+#endif /* DEBUG */
+#define err(format, arg...) printf("ERROR: " format "\n", ## arg)
+#undef SHOW_INFO
+#ifdef SHOW_INFO
+#define info(format, arg...) printf("INFO: " format "\n", ## arg)
+#else
+#define info(format, arg...) do {} while(0)
+#endif
+
+#define m16_swap(x) swap_16(x)
+#define m32_swap(x) swap_32(x)
+
+/* global struct ohci */
+static struct ohci gohci;
+/* this must be aligned to a 256 byte boundary */
+struct ohci_hcca ghcca[1];
+/* a pointer to the aligned storage */
+struct ohci_hcca *phcca;
+/* this allocates EDs for all possible endpoints */
+struct ohci_device ohci_dev;
+/* urb_priv */
+struct urb_priv urb_priv;
+/* RHSC flag */
+int got_rhsc;
+/* device which was disconnected */
+struct usb_device *devgone;
+/* flag guarding URB transation */
+int urb_finished = 0;
+
+/*-------------------------------------------------------------------------*/
+
+/* AMD-756 (D2 rev) reports corrupt register contents in some cases.
+ * The erratum (#4) description is incorrect.  AMD's workaround waits
+ * till some bits (mostly reserved) are clear; ok for all revs.
+ */
+#define OHCI_QUIRK_AMD756 0xabcd
+#define read_roothub(hc, register, mask) ({ \
+	u32 temp = readl (&hc->regs->roothub.register); \
+	if (hc->flags & OHCI_QUIRK_AMD756) \
+		while (temp & mask) \
+			temp = readl (&hc->regs->roothub.register); \
+	temp; })
+
+static u32 roothub_a(struct ohci *hc)
+{
+	return read_roothub(hc, a, 0xfc0fe000);
+}
+static inline u32 roothub_b(struct ohci *hc)
+{
+	return readl(&hc->regs->roothub.b);
+}
+static inline u32 roothub_status(struct ohci *hc)
+{
+	return readl(&hc->regs->roothub.status);
+}
+static u32 roothub_portstatus(struct ohci *hc, int i)
+{
+	return read_roothub(hc, portstatus[i], 0xffe0fce0);
+}
+
+/* forward declaration */
+static int hc_interrupt(void);
+static void td_submit_job(struct usb_device *dev, unsigned long pipe,
+			  void *buffer, int transfer_len,
+			  struct devrequest *setup, struct urb_priv *urb,
+			  int interval);
+
+/*-------------------------------------------------------------------------*
+ * URB support functions
+ *-------------------------------------------------------------------------*/
+
+/* free HCD-private data associated with this URB */
+
+static void urb_free_priv(struct urb_priv *urb)
+{
+	int i;
+	int last;
+	struct td *td;
+
+	last = urb->length - 1;
+	if (last >= 0) {
+		for (i = 0; i <= last; i++) {
+			td = urb->td[i];
+			if (td) {
+				td->usb_dev = NULL;
+				urb->td[i] = NULL;
+			}
+		}
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef DEBUG
+static int sohci_get_current_frame_number(struct usb_device *dev);
+
+/* debug| print the main components of an URB
+ * small: 0) header + data packets 1) just header */
+
+static void pkt_print(struct usb_device *dev, unsigned long pipe, void *buffer,
+		      int transfer_len, struct devrequest *setup, char *str,
+		      int small)
+{
+	struct urb_priv *purb = &urb_priv;
+
+	dbg("%s URB:[%4x] dev:%2d,ep:%2d-%c,type:%s,len:%d/%d stat:%#lx",
+	    str,
+	    sohci_get_current_frame_number(dev),
+	    usb_pipedevice(pipe),
+	    usb_pipeendpoint(pipe),
+	    usb_pipeout(pipe) ? 'O' : 'I',
+	    usb_pipetype(pipe) < 2 ?
+		(usb_pipeint(pipe) ? "INTR" : "ISOC") :
+		(usb_pipecontrol(pipe) ? "CTRL" : "BULK"),
+	    purb->actual_length, transfer_len, dev->status);
+#ifdef	OHCI_VERBOSE_DEBUG
+	if (!small) {
+		int i, len;
+
+		if (usb_pipecontrol(pipe)) {
+			printf(__FILE__ ": cmd(8):");
+			for (i = 0; i < 8; i++)
+				printf(" %02x", ((__u8 *) setup)[i]);
+			printf("\n");
+		}
+		if (transfer_len > 0 && buffer) {
+			printf(__FILE__ ": data(%d/%d):",
+			       purb->actual_length, transfer_len);
+			len = usb_pipeout(pipe) ?
+			    transfer_len : purb->actual_length;
+			for (i = 0; i < 16 && i < len; i++)
+				printf(" %02x", ((__u8 *) buffer)[i]);
+			printf("%s\n", i < len ? "..." : "");
+		}
+	}
+#endif
+}
+
+/* just for debugging; prints non-empty branches of the
+   int ed tree inclusive iso eds*/
+void ep_print_int_eds(struct ohci *ohci, char *str)
+{
+	int i, j;
+	__u32 *ed_p;
+	for (i = 0; i < 32; i++) {
+		j = 5;
+		ed_p = &(ohci->hcca->int_table[i]);
+		if (*ed_p == 0)
+			continue;
+		printf(__FILE__ ": %s branch int %2d(%2x):", str, i, i);
+		while (*ed_p != 0 && j--) {
+			struct ed *ed = (struct ed *) m32_swap(ed_p);
+			printf(" ed: %4x;", ed->hwINFO);
+			ed_p = &ed->hwNextED;
+		}
+		printf("\n");
+	}
+}
+
+static void ohci_dump_intr_mask(char *label, __u32 mask)
+{
+	dbg("%s: 0x%08x%s%s%s%s%s%s%s%s%s",
+	    label,
+	    mask,
+	    (mask & OHCI_INTR_MIE) ? " MIE" : "",
+	    (mask & OHCI_INTR_OC) ? " OC" : "",
+	    (mask & OHCI_INTR_RHSC) ? " RHSC" : "",
+	    (mask & OHCI_INTR_FNO) ? " FNO" : "",
+	    (mask & OHCI_INTR_UE) ? " UE" : "",
+	    (mask & OHCI_INTR_RD) ? " RD" : "",
+	    (mask & OHCI_INTR_SF) ? " SF" : "",
+	    (mask & OHCI_INTR_WDH) ? " WDH" : "",
+	    (mask & OHCI_INTR_SO) ? " SO" : "");
+}
+
+static void maybe_print_eds(char *label, __u32 value)
+{
+	struct ed *edp = (struct ed *) value;
+
+	if (value) {
+		dbg("%s %08x", label, value);
+		dbg("%08x", edp->hwINFO);
+		dbg("%08x", edp->hwTailP);
+		dbg("%08x", edp->hwHeadP);
+		dbg("%08x", edp->hwNextED);
+	}
+}
+
+static char *hcfs2string(int state)
+{
+	switch (state) {
+	case OHCI_USB_RESET:
+		return "reset";
+	case OHCI_USB_RESUME:
+		return "resume";
+	case OHCI_USB_OPER:
+		return "operational";
+	case OHCI_USB_SUSPEND:
+		return "suspend";
+	}
+	return "?";
+}
+
+/* dump control and status registers */
+static void ohci_dump_status(struct ohci *controller)
+{
+	struct ohci_regs *regs = controller->regs;
+	__u32 temp;
+
+	temp = readl(&regs->revision) & 0xff;
+	if (temp != 0x10)
+		dbg("spec %d.%d", (temp >> 4), (temp & 0x0f));
+
+	temp = readl(&regs->control);
+	dbg("control: 0x%08x%s%s%s HCFS=%s%s%s%s%s CBSR=%d", temp,
+	    (temp & OHCI_CTRL_RWE) ? " RWE" : "",
+	    (temp & OHCI_CTRL_RWC) ? " RWC" : "",
+	    (temp & OHCI_CTRL_IR) ? " IR" : "",
+	    hcfs2string(temp & OHCI_CTRL_HCFS),
+	    (temp & OHCI_CTRL_BLE) ? " BLE" : "",
+	    (temp & OHCI_CTRL_CLE) ? " CLE" : "",
+	    (temp & OHCI_CTRL_IE) ? " IE" : "",
+	    (temp & OHCI_CTRL_PLE) ? " PLE" : "", temp & OHCI_CTRL_CBSR);
+
+	temp = readl(&regs->cmdstatus);
+	dbg("cmdstatus: 0x%08x SOC=%d%s%s%s%s", temp,
+	    (temp & OHCI_SOC) >> 16,
+	    (temp & OHCI_OCR) ? " OCR" : "",
+	    (temp & OHCI_BLF) ? " BLF" : "",
+	    (temp & OHCI_CLF) ? " CLF" : "", (temp & OHCI_HCR) ? " HCR" : "");
+
+	ohci_dump_intr_mask("intrstatus", readl(&regs->intrstatus));
+	ohci_dump_intr_mask("intrenable", readl(&regs->intrenable));
+
+	maybe_print_eds("ed_periodcurrent", readl(&regs->ed_periodcurrent));
+
+	maybe_print_eds("ed_controlhead", readl(&regs->ed_controlhead));
+	maybe_print_eds("ed_controlcurrent", readl(&regs->ed_controlcurrent));
+
+	maybe_print_eds("ed_bulkhead", readl(&regs->ed_bulkhead));
+	maybe_print_eds("ed_bulkcurrent", readl(&regs->ed_bulkcurrent));
+
+	maybe_print_eds("donehead", readl(&regs->donehead));
+}
+
+static void ohci_dump_roothub(struct ohci *controller, int verbose)
+{
+	__u32 temp, ndp, i;
+
+	temp = roothub_a(controller);
+	ndp = (temp & RH_A_NDP);
+
+	if (verbose) {
+		dbg("roothub.a: %08x POTPGT=%d%s%s%s%s%s NDP=%d", temp,
+		    ((temp & RH_A_POTPGT) >> 24) & 0xff,
+		    (temp & RH_A_NOCP) ? " NOCP" : "",
+		    (temp & RH_A_OCPM) ? " OCPM" : "",
+		    (temp & RH_A_DT) ? " DT" : "",
+		    (temp & RH_A_NPS) ? " NPS" : "",
+		    (temp & RH_A_PSM) ? " PSM" : "", ndp);
+		temp = roothub_b(controller);
+		dbg("roothub.b: %08x PPCM=%04x DR=%04x",
+		    temp, (temp & RH_B_PPCM) >> 16, (temp & RH_B_DR)
+		    );
+		temp = roothub_status(controller);
+		dbg("roothub.status: %08x%s%s%s%s%s%s",
+		    temp,
+		    (temp & RH_HS_CRWE) ? " CRWE" : "",
+		    (temp & RH_HS_OCIC) ? " OCIC" : "",
+		    (temp & RH_HS_LPSC) ? " LPSC" : "",
+		    (temp & RH_HS_DRWE) ? " DRWE" : "",
+		    (temp & RH_HS_OCI) ? " OCI" : "",
+		    (temp & RH_HS_LPS) ? " LPS" : "");
+	}
+
+	for (i = 0; i < ndp; i++) {
+		temp = roothub_portstatus(controller, i);
+		dbg("roothub.portstatus [%d] = 0x%08x%s%s%s%s%s%s%s%s%s%s%s%s",
+		    i,
+		    temp,
+		    (temp & RH_PS_PRSC) ? " PRSC" : "",
+		    (temp & RH_PS_OCIC) ? " OCIC" : "",
+		    (temp & RH_PS_PSSC) ? " PSSC" : "",
+		    (temp & RH_PS_PESC) ? " PESC" : "",
+		    (temp & RH_PS_CSC) ? " CSC" : "",
+		    (temp & RH_PS_LSDA) ? " LSDA" : "",
+		    (temp & RH_PS_PPS) ? " PPS" : "",
+		    (temp & RH_PS_PRS) ? " PRS" : "",
+		    (temp & RH_PS_POCI) ? " POCI" : "",
+		    (temp & RH_PS_PSS) ? " PSS" : "",
+		    (temp & RH_PS_PES) ? " PES" : "",
+		    (temp & RH_PS_CCS) ? " CCS" : "");
+	}
+}
+
+static void ohci_dump(struct ohci *controller, int verbose)
+{
+	dbg("OHCI controller usb-%s state", controller->slot_name);
+
+	/* dumps some of the state we know about */
+	ohci_dump_status(controller);
+	if (verbose)
+		ep_print_int_eds(controller, "hcca");
+	dbg("hcca frame #%04x", controller->hcca->frame_no);
+	ohci_dump_roothub(controller, 1);
+}
+
+#endif /* DEBUG */
+
+/*-------------------------------------------------------------------------*
+ * Interface functions (URB)
+ *-------------------------------------------------------------------------*/
+
+/* get a transfer request */
+
+int sohci_submit_job(struct usb_device *dev, unsigned long pipe, void *buffer,
+		     int transfer_len, struct devrequest *setup, int interval)
+{
+	struct ohci *ohci;
+	struct ed *ed;
+	struct urb_priv *purb_priv;
+	int i, size = 0;
+
+	ohci = &gohci;
+
+	/* when controller's hung, permit only roothub cleanup attempts
+	 * such as powering down ports */
+	if (ohci->disabled) {
+		err("sohci_submit_job: EPIPE");
+		return -1;
+	}
+
+	/* if we have an unfinished URB from previous transaction let's
+	 * fail and scream as quickly as possible so as not to corrupt
+	 * further communication */
+	if (!urb_finished) {
+		err("sohci_submit_job: URB NOT FINISHED");
+		return -1;
+	}
+	/* we're about to begin a new transaction here
+	   so mark the URB unfinished */
+	urb_finished = 0;
+
+	/* every endpoint has a ed, locate and fill it */
+	ed = ep_add_ed(dev, pipe);
+	if (!ed) {
+		err("sohci_submit_job: ENOMEM");
+		return -1;
+	}
+
+	/* for the private part of the URB we need the number of TDs (size) */
+	switch (usb_pipetype(pipe)) {
+	case PIPE_BULK:
+		/* one TD for every 4096 Byte */
+		size = (transfer_len - 1) / 4096 + 1;
+		break;
+	case PIPE_CONTROL:
+		/* 1 TD for setup, 1 for ACK and 1 for every 4096 B */
+		size = (transfer_len == 0) ? 2 : (transfer_len - 1) / 4096 + 3;
+		break;
+	}
+
+	if (size >= (N_URB_TD - 1)) {
+		err("need %d TDs, only have %d", size, N_URB_TD);
+		return -1;
+	}
+	purb_priv = &urb_priv;
+	purb_priv->pipe = pipe;
+
+	/* fill the private part of the URB */
+	purb_priv->length = size;
+	purb_priv->ed = ed;
+	purb_priv->actual_length = 0;
+
+	/* allocate the TDs */
+	/* note that td[0] was allocated in ep_add_ed */
+	for (i = 0; i < size; i++) {
+		purb_priv->td[i] = td_alloc(dev);
+		if (!purb_priv->td[i]) {
+			purb_priv->length = i;
+			urb_free_priv(purb_priv);
+			err("sohci_submit_job: ENOMEM");
+			return -1;
+		}
+	}
+
+	if (ed->state == ED_NEW || (ed->state & ED_DEL)) {
+		urb_free_priv(purb_priv);
+		err("sohci_submit_job: EINVAL");
+		return -1;
+	}
+
+	/* link the ed into a chain if is not already */
+	if (ed->state != ED_OPER)
+		ep_link(ohci, ed);
+
+	/* fill the TDs and link it to the ed */
+	td_submit_job(dev, pipe, buffer, transfer_len, setup, purb_priv,
+		      interval);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef DEBUG
+/* tell us the current USB frame number */
+
+static int sohci_get_current_frame_number(struct usb_device *usb_dev)
+{
+	struct ohci *ohci = &gohci;
+
+	return m16_swap(ohci->hcca->frame_no);
+}
+#endif
+
+/*-------------------------------------------------------------------------*
+ * ED handling functions
+ *-------------------------------------------------------------------------*/
+
+/* link an ed into one of the HC chains */
+
+static int ep_link(struct ohci *ohci, struct ed *edi)
+{
+	struct ed *ed = edi;
+
+	ed->state = ED_OPER;
+
+	switch (ed->type) {
+	case PIPE_CONTROL:
+		ed->hwNextED = 0;
+		if (ohci->ed_controltail == NULL) {
+			writel((u32)ed, &ohci->regs->ed_controlhead);
+		} else {
+			ohci->ed_controltail->hwNextED = (__u32) m32_swap(ed);
+		}
+		ed->ed_prev = ohci->ed_controltail;
+		if (!ohci->ed_controltail && !ohci->ed_rm_list[0] &&
+		    !ohci->ed_rm_list[1] && !ohci->sleeping) {
+			ohci->hc_control |= OHCI_CTRL_CLE;
+			writel(ohci->hc_control, &ohci->regs->control);
+		}
+		ohci->ed_controltail = edi;
+		break;
+
+	case PIPE_BULK:
+		ed->hwNextED = 0;
+		if (ohci->ed_bulktail == NULL) {
+			writel((u32)ed, &ohci->regs->ed_bulkhead);
+		} else {
+			ohci->ed_bulktail->hwNextED = (__u32) m32_swap(ed);
+		}
+		ed->ed_prev = ohci->ed_bulktail;
+		if (!ohci->ed_bulktail && !ohci->ed_rm_list[0] &&
+		    !ohci->ed_rm_list[1] && !ohci->sleeping) {
+			ohci->hc_control |= OHCI_CTRL_BLE;
+			writel(ohci->hc_control, &ohci->regs->control);
+		}
+		ohci->ed_bulktail = edi;
+		break;
+	}
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* unlink an ed from one of the HC chains.
+ * just the link to the ed is unlinked.
+ * the link from the ed still points to another operational ed or 0
+ * so the HC can eventually finish the processing of the unlinked ed */
+
+static int ep_unlink(struct ohci *ohci, struct ed *ed)
+{
+	struct ed *next;
+	ed->hwINFO |= m32_swap(OHCI_ED_SKIP);
+
+	switch (ed->type) {
+	case PIPE_CONTROL:
+		if (ed->ed_prev == NULL) {
+			if (!ed->hwNextED) {
+				ohci->hc_control &= ~OHCI_CTRL_CLE;
+				writel(ohci->hc_control, &ohci->regs->control);
+			}
+			writel(m32_swap(*((__u32 *) &ed->hwNextED)),
+			       &ohci->regs->ed_controlhead);
+		} else {
+			ed->ed_prev->hwNextED = ed->hwNextED;
+		}
+		if (ohci->ed_controltail == ed) {
+			ohci->ed_controltail = ed->ed_prev;
+		} else {
+			next = (struct ed *)m32_swap(*((__u32 *)&ed->hwNextED));
+			next->ed_prev = ed->ed_prev;
+		}
+		break;
+
+	case PIPE_BULK:
+		if (ed->ed_prev == NULL) {
+			if (!ed->hwNextED) {
+				ohci->hc_control &= ~OHCI_CTRL_BLE;
+				writel(ohci->hc_control, &ohci->regs->control);
+			}
+			writel(m32_swap(*((__u32 *) &ed->hwNextED)),
+			       &ohci->regs->ed_bulkhead);
+		} else {
+			ed->ed_prev->hwNextED = ed->hwNextED;
+		}
+		if (ohci->ed_bulktail == ed) {
+			ohci->ed_bulktail = ed->ed_prev;
+		} else {
+			next = (struct ed *)m32_swap(*((__u32 *)&ed->hwNextED));
+			next->ed_prev = ed->ed_prev;
+		}
+		break;
+	}
+	ed->state = ED_UNLINK;
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* add/reinit an endpoint; this should be done once at the usb_set_configuration
+ * command, but the USB stack is a little bit stateless  so we do it at every
+ * transaction. If the state of the ed is ED_NEW then a dummy td is added and
+ * the state is changed to ED_UNLINK. In all other cases the state is left
+ * unchanged. The ed info fields are setted anyway even though most of them
+ * should not change */
+
+static struct ed *ep_add_ed(struct usb_device *usb_dev, unsigned long pipe)
+{
+	struct td *td;
+	struct ed *ed_ret;
+	struct ed *ed;
+
+	ed = ed_ret = &ohci_dev.ed[(usb_pipeendpoint(pipe) << 1) |
+				   (usb_pipecontrol(pipe) ? 0 :
+				    usb_pipeout(pipe))];
+
+	if ((ed->state & ED_DEL) || (ed->state & ED_URB_DEL)) {
+		err("ep_add_ed: pending delete");
+		/* pending delete request */
+		return NULL;
+	}
+
+	if (ed->state == ED_NEW) {
+		ed->hwINFO = m32_swap(OHCI_ED_SKIP);	/* skip ed */
+		/* dummy td; end of td list for ed */
+		td = td_alloc(usb_dev);
+		ed->hwTailP = (__u32) m32_swap(td);
+		ed->hwHeadP = ed->hwTailP;
+		ed->state = ED_UNLINK;
+		ed->type = usb_pipetype(pipe);
+		ohci_dev.ed_cnt++;
+	}
+
+	ed->hwINFO = m32_swap(usb_pipedevice(pipe)
+			      | usb_pipeendpoint(pipe) << 7
+			      | (usb_pipeisoc(pipe) ? 0x8000 : 0)
+			      | (usb_pipecontrol(pipe) ? 0 :
+				 (usb_pipeout(pipe) ? 0x800 : 0x1000))
+			      | (usb_dev->speed == USB_SPEED_LOW) << 13 |
+			      usb_maxpacket(usb_dev, pipe) << 16);
+
+	return ed_ret;
+}
+
+/*-------------------------------------------------------------------------*
+ * TD handling functions
+ *-------------------------------------------------------------------------*/
+
+/* enqueue next TD for this URB (OHCI spec 5.2.8.2) */
+
+static void td_fill(struct ohci *ohci, unsigned int info, void *data, int len,
+		    struct usb_device *dev, int index,
+		    struct urb_priv *urb_priv)
+{
+	struct td *td, *td_pt;
+#ifdef OHCI_FILL_TRACE
+	int i;
+#endif
+
+	if (index > urb_priv->length) {
+		err("index > length");
+		return;
+	}
+	/* use this td as the next dummy */
+	td_pt = urb_priv->td[index];
+	td_pt->hwNextTD = 0;
+
+	/* fill the old dummy TD */
+	td = urb_priv->td[index] =
+	    (struct td *) (m32_swap(urb_priv->ed->hwTailP) & ~0xf);
+
+	td->ed = urb_priv->ed;
+	td->next_dl_td = NULL;
+	td->index = index;
+	td->data = (__u32) data;
+#ifdef OHCI_FILL_TRACE
+	if (usb_pipebulk(urb_priv->pipe) && usb_pipeout(urb_priv->pipe)) {
+		for (i = 0; i < len; i++)
+			printf("td->data[%d] %#2x ", i,
+			       ((unsigned char *)td->data)[i]);
+		printf("\n");
+	}
+#endif
+	if (!len)
+		data = 0;
+
+	td->hwINFO = (__u32) m32_swap(info);
+	td->hwCBP = (__u32) m32_swap(data);
+	if (data)
+		td->hwBE = (__u32) m32_swap(data + len - 1);
+	else
+		td->hwBE = 0;
+	td->hwNextTD = (__u32) m32_swap(td_pt);
+
+	/* append to queue */
+	td->ed->hwTailP = td->hwNextTD;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* prepare all TDs of a transfer */
+
+static void td_submit_job(struct usb_device *dev, unsigned long pipe,
+			  void *buffer, int transfer_len,
+			  struct devrequest *setup, struct urb_priv *urb,
+			  int interval)
+{
+	struct ohci *ohci = &gohci;
+	int data_len = transfer_len;
+	void *data;
+	int cnt = 0;
+	__u32 info = 0;
+	unsigned int toggle = 0;
+
+	/* OHCI handles the DATA-toggles itself, we just
+	   use the USB-toggle bits for resetting */
+	if (usb_gettoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe))) {
+		toggle = TD_T_TOGGLE;
+	} else {
+		toggle = TD_T_DATA0;
+		usb_settoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe),
+			      1);
+	}
+	urb->td_cnt = 0;
+	if (data_len)
+		data = buffer;
+	else
+		data = 0;
+
+	switch (usb_pipetype(pipe)) {
+	case PIPE_BULK:
+		info = usb_pipeout(pipe) ? TD_CC | TD_DP_OUT : TD_CC | TD_DP_IN;
+		while (data_len > 4096) {
+			td_fill(ohci, info | (cnt ? TD_T_TOGGLE : toggle), data,
+				4096, dev, cnt, urb);
+			data += 4096;
+			data_len -= 4096;
+			cnt++;
+		}
+		info = usb_pipeout(pipe) ?
+				TD_CC | TD_DP_OUT :
+				TD_CC | TD_R | TD_DP_IN;
+		td_fill(ohci, info | (cnt ? TD_T_TOGGLE : toggle), data,
+			data_len, dev, cnt, urb);
+		cnt++;
+
+		if (!ohci->sleeping)
+			/* start bulk list */
+			writel(OHCI_BLF, &ohci->regs->cmdstatus);
+		break;
+
+	case PIPE_CONTROL:
+		info = TD_CC | TD_DP_SETUP | TD_T_DATA0;
+		td_fill(ohci, info, setup, 8, dev, cnt++, urb);
+		if (data_len > 0) {
+			info = usb_pipeout(pipe) ?
+			    TD_CC | TD_R | TD_DP_OUT | TD_T_DATA1 :
+			    TD_CC | TD_R | TD_DP_IN | TD_T_DATA1;
+			/* NOTE:  mishandles transfers >8K, some >4K */
+			td_fill(ohci, info, data, data_len, dev, cnt++, urb);
+		}
+		info = usb_pipeout(pipe) ?
+		    TD_CC | TD_DP_IN | TD_T_DATA1 :
+		    TD_CC | TD_DP_OUT | TD_T_DATA1;
+		td_fill(ohci, info, data, 0, dev, cnt++, urb);
+		if (!ohci->sleeping)
+			/* start Control list */
+			writel(OHCI_CLF, &ohci->regs->cmdstatus);
+		break;
+	}
+	if (urb->length != cnt)
+		dbg("TD LENGTH %d != CNT %d", urb->length, cnt);
+}
+
+/*-------------------------------------------------------------------------*
+ * Done List handling functions
+ *-------------------------------------------------------------------------*/
+
+
+/* calculate the transfer length and update the urb */
+
+static void dl_transfer_length(struct td *td)
+{
+	__u32 tdBE, tdCBP;
+	struct urb_priv *lurb_priv = &urb_priv;
+
+	tdBE = m32_swap(td->hwBE);
+	tdCBP = m32_swap(td->hwCBP);
+
+	if (!(usb_pipecontrol(lurb_priv->pipe) &&
+	      ((td->index == 0) || (td->index == lurb_priv->length - 1)))) {
+		if (tdBE != 0) {
+			if (td->hwCBP == 0)
+				lurb_priv->actual_length += tdBE - td->data + 1;
+			else
+				lurb_priv->actual_length += tdCBP - td->data;
+		}
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* replies to the request have to be on a FIFO basis so
+ * we reverse the reversed done-list */
+
+static struct td *dl_reverse_done_list(struct ohci *ohci)
+{
+	__u32 td_list_hc;
+	__u32 tmp;
+	struct td *td_rev = NULL;
+	struct td *td_list = NULL;
+	struct urb_priv *lurb_priv = NULL;
+
+	td_list_hc = m32_swap(ohci->hcca->done_head) & 0xfffffff0;
+	ohci->hcca->done_head = 0;
+
+	while (td_list_hc) {
+		td_list = (struct td *) td_list_hc;
+
+		if (TD_CC_GET(m32_swap(td_list->hwINFO))) {
+			lurb_priv = &urb_priv;
+			dbg(" USB-error/status: %x : %p",
+			    TD_CC_GET(m32_swap(td_list->hwINFO)), td_list);
+			if (td_list->ed->hwHeadP & m32_swap(0x1)) {
+				if (lurb_priv &&
+				    ((td_list->index+1) < lurb_priv->length)) {
+					tmp = lurb_priv->length - 1;
+					td_list->ed->hwHeadP =
+						(lurb_priv->td[tmp]->hwNextTD &
+						 m32_swap(0xfffffff0)) |
+						 (td_list->ed->hwHeadP &
+						  m32_swap(0x2));
+					lurb_priv->td_cnt += lurb_priv->length -
+							     td_list->index - 1;
+				} else
+					td_list->ed->hwHeadP &=
+					    m32_swap(0xfffffff2);
+			}
+		}
+
+		td_list->next_dl_td = td_rev;
+		td_rev = td_list;
+		td_list_hc = m32_swap(td_list->hwNextTD) & 0xfffffff0;
+	}
+
+	return td_list;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* td done list */
+static int dl_done_list(struct ohci *ohci, struct td *td_list)
+{
+	struct td *td_list_next = NULL;
+	struct ed *ed;
+	int cc = 0;
+	int stat = 0;
+	/* urb_t *urb; */
+	struct urb_priv *lurb_priv;
+	__u32 tdINFO, edHeadP, edTailP;
+
+	while (td_list) {
+		td_list_next = td_list->next_dl_td;
+
+		lurb_priv = &urb_priv;
+		tdINFO = m32_swap(td_list->hwINFO);
+
+		ed = td_list->ed;
+
+		dl_transfer_length(td_list);
+
+		/* error code of transfer */
+		cc = TD_CC_GET(tdINFO);
+		if (cc != 0) {
+			dbg("ConditionCode %#x", cc);
+			stat = cc_to_error[cc];
+		}
+
+		/* see if this done list makes for all TD's of current URB,
+		 * and mark the URB finished if so */
+		if (++(lurb_priv->td_cnt) == lurb_priv->length) {
+			if ((ed->state & (ED_OPER | ED_UNLINK)))
+				urb_finished = 1;
+			else
+				dbg("dl_done_list: strange.., ED state %x, "
+				    "ed->state\n");
+		} else
+			dbg("dl_done_list: processing TD %x, len %x\n",
+			    lurb_priv->td_cnt, lurb_priv->length);
+
+		if (ed->state != ED_NEW) {
+			edHeadP = m32_swap(ed->hwHeadP) & 0xfffffff0;
+			edTailP = m32_swap(ed->hwTailP);
+
+			/* unlink eds if they are not busy */
+			if ((edHeadP == edTailP) && (ed->state == ED_OPER))
+				ep_unlink(ohci, ed);
+		}
+
+		td_list = td_list_next;
+	}
+	return stat;
+}
+
+/*-------------------------------------------------------------------------*
+ * Virtual Root Hub
+ *-------------------------------------------------------------------------*/
+
+#include <usbroothubdes.h>
+
+/* Hub class-specific descriptor is constructed dynamically */
+
+
+/*-------------------------------------------------------------------------*/
+
+#define OK(x)			len = (x); break
+#ifdef DEBUG
+#define WR_RH_STAT(x) \
+{ \
+	info("WR:status %#8x", (x)); \
+	writel((x), &gohci.regs->roothub.status); \
+}
+#define WR_RH_PORTSTAT(x) \
+{ \
+	info("WR:portstatus[%d] %#8x", wIndex-1, (x)); \
+	writel((x), &gohci.regs->roothub.portstatus[wIndex-1]); \
+}
+#else
+#define WR_RH_STAT(x) \
+	writel((x), &gohci.regs->roothub.status)
+#define WR_RH_PORTSTAT(x)\
+	writel((x), &gohci.regs->roothub.portstatus[wIndex-1])
+#endif
+#define RD_RH_STAT	roothub_status(&gohci)
+#define RD_RH_PORTSTAT	roothub_portstatus(&gohci, wIndex-1)
+
+/* request to virtual root hub */
+
+int rh_check_port_status(struct ohci *controller)
+{
+	__u32 temp, ndp, i;
+	int res;
+
+	res = -1;
+	temp = roothub_a(controller);
+	ndp = (temp & RH_A_NDP);
+	for (i = 0; i < ndp; i++) {
+		temp = roothub_portstatus(controller, i);
+		/* check for a device disconnect */
+		if (((temp & (RH_PS_PESC | RH_PS_CSC)) ==
+		     (RH_PS_PESC | RH_PS_CSC)) && ((temp & RH_PS_CCS) == 0)) {
+			res = i;
+			break;
+		}
+	}
+	return res;
+}
+
+static int ohci_submit_rh_msg(struct usb_device *dev, unsigned long pipe,
+			      void *buffer, int transfer_len,
+			      struct devrequest *cmd)
+{
+	void *data = buffer;
+	int leni = transfer_len;
+	int len = 0;
+	int stat = 0;
+	union {
+		__u32 word[4];
+		__u16 hword[8];
+		__u8 byte[16];
+	} datab;
+	__u8 *data_buf = datab.byte;
+	__u16 bmRType_bReq;
+	__u16 wValue;
+	__u16 wIndex;
+	__u16 wLength;
+
+#ifdef DEBUG
+	urb_priv.actual_length = 0;
+	pkt_print(dev, pipe, buffer, transfer_len, cmd, "SUB(rh)",
+		  usb_pipein(pipe));
+#else
+	mdelay(1);
+#endif
+	if (usb_pipeint(pipe)) {
+		info("Root-Hub submit IRQ: NOT implemented");
+		return 0;
+	}
+
+	bmRType_bReq = cmd->requesttype | (cmd->request << 8);
+	wValue = m16_swap(cmd->value);
+	wIndex = m16_swap(cmd->index);
+	wLength = m16_swap(cmd->length);
+
+	info("Root-Hub: adr: %2x cmd(%1x): %08x %04x %04x %04x",
+	     dev->devnum, 8, bmRType_bReq, wValue, wIndex, wLength);
+
+	switch (bmRType_bReq) {
+		/* Request Destination:
+		   without flags: Device,
+		   RH_INTERFACE: interface,
+		   RH_ENDPOINT: endpoint,
+		   RH_CLASS means HUB here,
+		   RH_OTHER | RH_CLASS  almost ever means HUB_PORT here
+		 */
+
+	case RH_GET_STATUS:
+		datab.hword[0] = m16_swap(1);
+		OK(2);
+	case RH_GET_STATUS | RH_INTERFACE:
+		datab.hword[0] = m16_swap(0);
+		OK(2);
+	case RH_GET_STATUS | RH_ENDPOINT:
+		datab.hword[0] = m16_swap(0);
+		OK(2);
+	case RH_GET_STATUS | RH_CLASS:
+		datab.word[0] =
+		    m32_swap(RD_RH_STAT & ~(RH_HS_CRWE | RH_HS_DRWE));
+		OK(4);
+	case RH_GET_STATUS | RH_OTHER | RH_CLASS:
+		datab.word[0] = m32_swap(RD_RH_PORTSTAT);
+		OK(4);
+
+	case RH_CLEAR_FEATURE | RH_ENDPOINT:
+		switch (wValue) {
+		case (RH_ENDPOINT_STALL):
+			OK(0);
+		}
+		break;
+
+	case RH_CLEAR_FEATURE | RH_CLASS:
+		switch (wValue) {
+		case RH_C_HUB_LOCAL_POWER:
+			OK(0);
+		case (RH_C_HUB_OVER_CURRENT):
+			WR_RH_STAT(RH_HS_OCIC);
+			OK(0);
+		}
+		break;
+
+	case RH_CLEAR_FEATURE | RH_OTHER | RH_CLASS:
+		switch (wValue) {
+		case (RH_PORT_ENABLE):
+			WR_RH_PORTSTAT(RH_PS_CCS);
+			OK(0);
+		case (RH_PORT_SUSPEND):
+			WR_RH_PORTSTAT(RH_PS_POCI);
+			OK(0);
+		case (RH_PORT_POWER):
+			WR_RH_PORTSTAT(RH_PS_LSDA);
+			OK(0);
+		case (RH_C_PORT_CONNECTION):
+			WR_RH_PORTSTAT(RH_PS_CSC);
+			OK(0);
+		case (RH_C_PORT_ENABLE):
+			WR_RH_PORTSTAT(RH_PS_PESC);
+			OK(0);
+		case (RH_C_PORT_SUSPEND):
+			WR_RH_PORTSTAT(RH_PS_PSSC);
+			OK(0);
+		case (RH_C_PORT_OVER_CURRENT):
+			WR_RH_PORTSTAT(RH_PS_OCIC);
+			OK(0);
+		case (RH_C_PORT_RESET):
+			WR_RH_PORTSTAT(RH_PS_PRSC);
+			OK(0);
+		}
+		break;
+
+	case RH_SET_FEATURE | RH_OTHER | RH_CLASS:
+		switch (wValue) {
+		case (RH_PORT_SUSPEND):
+			WR_RH_PORTSTAT(RH_PS_PSS);
+			OK(0);
+		case (RH_PORT_RESET):	/* BUG IN HUP CODE ******** */
+			if (RD_RH_PORTSTAT & RH_PS_CCS)
+				WR_RH_PORTSTAT(RH_PS_PRS);
+			OK(0);
+		case (RH_PORT_POWER):
+			WR_RH_PORTSTAT(RH_PS_PPS);
+			OK(0);
+		case (RH_PORT_ENABLE):	/* BUG IN HUP CODE ******** */
+			if (RD_RH_PORTSTAT & RH_PS_CCS)
+				WR_RH_PORTSTAT(RH_PS_PES);
+			OK(0);
+		}
+		break;
+
+	case RH_SET_ADDRESS:
+		gohci.rh.devnum = wValue;
+		OK(0);
+
+	case RH_GET_DESCRIPTOR:
+		switch ((wValue & 0xff00) >> 8) {
+		case (0x01):	/* device descriptor */
+			len = min_t(unsigned int,
+				    leni,
+				    min_t(unsigned int,
+					  sizeof(root_hub_dev_des), wLength));
+			data_buf = root_hub_dev_des;
+			OK(len);
+		case (0x02):	/* configuration descriptor */
+			len = min_t(unsigned int,
+				    leni,
+				    min_t(unsigned int,
+					  sizeof(root_hub_config_des),
+					  wLength));
+			data_buf = root_hub_config_des;
+			OK(len);
+		case (0x03):	/* string descriptors */
+			if (wValue == 0x0300) {
+				len = min_t(unsigned int,
+					    leni,
+					    min_t(unsigned int,
+						  sizeof(root_hub_str_index0),
+						  wLength));
+				data_buf = root_hub_str_index0;
+				OK(len);
+			}
+			if (wValue == 0x0301) {
+				len = min_t(unsigned int,
+					    leni,
+					    min_t(unsigned int,
+						  sizeof(root_hub_str_index1),
+						  wLength));
+				data_buf = root_hub_str_index1;
+				OK(len);
+			}
+		default:
+			stat = USB_ST_STALLED;
+		}
+		break;
+
+	case RH_GET_DESCRIPTOR | RH_CLASS:
+		{
+			__u32 temp = roothub_a(&gohci);
+
+			data_buf[0] = 9;	/* min length; */
+			data_buf[1] = 0x29;
+			data_buf[2] = temp & RH_A_NDP;
+			data_buf[3] = 0;
+			if (temp & RH_A_PSM)
+				/* per-port power switching? */
+				data_buf[3] |= 0x1;
+			if (temp & RH_A_NOCP)
+				/* no overcurrent reporting? */
+				data_buf[3] |= 0x10;
+			else if (temp & RH_A_OCPM)
+				/* per-port overcurrent reporting? */
+				data_buf[3] |= 0x8;
+
+			/* corresponds to data_buf[4-7] */
+			datab.word[1] = 0;
+			data_buf[5] = (temp & RH_A_POTPGT) >> 24;
+			temp = roothub_b(&gohci);
+			data_buf[7] = temp & RH_B_DR;
+			if (data_buf[2] < 7) {
+				data_buf[8] = 0xff;
+			} else {
+				data_buf[0] += 2;
+				data_buf[8] = (temp & RH_B_DR) >> 8;
+				data_buf[10] = data_buf[9] = 0xff;
+			}
+
+			len = min_t(unsigned int, leni,
+				    min_t(unsigned int, data_buf[0], wLength));
+			OK(len);
+		}
+
+	case RH_GET_CONFIGURATION:
+		*(__u8 *) data_buf = 0x01;
+		OK(1);
+
+	case RH_SET_CONFIGURATION:
+		WR_RH_STAT(0x10000);
+		OK(0);
+
+	default:
+		dbg("unsupported root hub command");
+		stat = USB_ST_STALLED;
+	}
+
+#ifdef	DEBUG
+	ohci_dump_roothub(&gohci, 1);
+#else
+	mdelay(1);
+#endif
+
+	len = min_t(int, len, leni);
+	if (data != data_buf)
+		memcpy(data, data_buf, len);
+	dev->act_len = len;
+	dev->status = stat;
+
+#ifdef DEBUG
+	if (transfer_len)
+		urb_priv.actual_length = transfer_len;
+	pkt_print(dev, pipe, buffer, transfer_len, cmd, "RET(rh)",
+		  0 /*usb_pipein(pipe) */);
+#else
+	mdelay(1);
+#endif
+
+	return stat;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* common code for handling submit messages - used for all but root hub */
+/* accesses. */
+int submit_common_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+		      int transfer_len, struct devrequest *setup, int interval)
+{
+	int stat = 0;
+	int maxsize = usb_maxpacket(dev, pipe);
+	int timeout;
+
+	/* device pulled? Shortcut the action. */
+	if (devgone == dev) {
+		dev->status = USB_ST_CRC_ERR;
+		return 0;
+	}
+#ifdef DEBUG
+	urb_priv.actual_length = 0;
+	pkt_print(dev, pipe, buffer, transfer_len, setup, "SUB",
+		  usb_pipein(pipe));
+#else
+	mdelay(1);
+#endif
+	if (!maxsize) {
+		err("submit_common_message: pipesize for pipe %lx is zero",
+		    pipe);
+		return -1;
+	}
+
+	if (sohci_submit_job(dev, pipe, buffer, transfer_len, setup, interval) <
+	    0) {
+		err("sohci_submit_job failed");
+		return -1;
+	}
+
+	mdelay(10);
+	/* ohci_dump_status(&gohci); */
+
+	/* allow more time for a BULK device to react - some are slow */
+#define BULK_TO	 5000		/* timeout in milliseconds */
+	if (usb_pipebulk(pipe))
+		timeout = BULK_TO;
+	else
+		timeout = 100;
+
+	/* wait for it to complete */
+	for (;;) {
+		/* check whether the controller is done */
+		stat = hc_interrupt();
+
+		if (stat < 0) {
+			stat = USB_ST_CRC_ERR;
+			break;
+		}
+
+		/* NOTE: since we are not interrupt driven in U-Boot and always
+		 * handle only one URB at a time, we cannot assume the
+		 * transaction finished on the first successful return from
+		 * hc_interrupt().. unless the flag for current URB is set,
+		 * meaning that all TD's to/from device got actually
+		 * transferred and processed. If the current URB is not
+		 * finished we need to re-iterate this loop so as
+		 * hc_interrupt() gets called again as there needs to be some
+		 * more TD's to process still */
+		if ((stat >= 0) && (stat != 0xff) && (urb_finished)) {
+			/* 0xff is returned for an SF-interrupt */
+			break;
+		}
+
+		if (--timeout) {
+			mdelay(1);
+			if (!urb_finished)
+				dbg("\%");
+
+		} else {
+			err("CTL:TIMEOUT ");
+			dbg("submit_common_msg: TO status %x\n", stat);
+			stat = USB_ST_CRC_ERR;
+			urb_finished = 1;
+			break;
+		}
+	}
+
+#if 0
+	/* we got an Root Hub Status Change interrupt */
+	if (got_rhsc) {
+#ifdef DEBUG
+		ohci_dump_roothub(&gohci, 1);
+#endif
+		got_rhsc = 0;
+		/* abuse timeout */
+		timeout = rh_check_port_status(&gohci);
+		if (timeout >= 0) {
+#if 0			/* this does nothing useful, but leave it here
+			   in case that changes */
+			/* the called routine adds 1 to the passed value */
+			usb_hub_port_connect_change(gohci.rh.dev, timeout - 1);
+#endif
+			/*
+			 * XXX
+			 * This is potentially dangerous because it assumes
+			 * that only one device is ever plugged in!
+			 */
+			devgone = dev;
+		}
+	}
+#endif
+
+	dev->status = stat;
+	dev->act_len = transfer_len;
+
+#ifdef DEBUG
+	pkt_print(dev, pipe, buffer, transfer_len, setup, "RET(ctlr)",
+		  usb_pipein(pipe));
+#else
+	mdelay(1);
+#endif
+
+	/* free TDs in urb_priv */
+	urb_free_priv(&urb_priv);
+	return 0;
+}
+
+/* submit routines called from usb.c */
+int submit_bulk_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+		    int transfer_len)
+{
+	info("submit_bulk_msg");
+	return submit_common_msg(dev, pipe, buffer, transfer_len, NULL, 0);
+}
+
+int submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+		       int transfer_len, struct devrequest *setup)
+{
+	int maxsize = usb_maxpacket(dev, pipe);
+
+	info("submit_control_msg");
+#ifdef DEBUG
+	urb_priv.actual_length = 0;
+	pkt_print(dev, pipe, buffer, transfer_len, setup, "SUB",
+		  usb_pipein(pipe));
+#else
+	mdelay(1);
+#endif
+	if (!maxsize) {
+		err("submit_control_message: pipesize for pipe %lx is zero",
+		    pipe);
+		return -1;
+	}
+	if (((pipe >> 8) & 0x7f) == gohci.rh.devnum) {
+		gohci.rh.dev = dev;
+		/* root hub - redirect */
+		return ohci_submit_rh_msg(dev, pipe, buffer, transfer_len,
+					  setup);
+	}
+
+	return submit_common_msg(dev, pipe, buffer, transfer_len, setup, 0);
+}
+
+/*DaQui Modified*/
+int submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+		   int transfer_len, int interval, bool nonblock)
+{
+	info("submit_int_msg");
+	return -1;
+}
+
+/*-------------------------------------------------------------------------*
+ * HC functions
+ *-------------------------------------------------------------------------*/
+
+/* reset the HC and BUS */
+
+static int hc_reset(struct ohci *ohci)
+{
+	int timeout = 30;
+	int smm_timeout = 50;	/* 0,5 sec */
+
+	if (readl(&ohci->regs->control) & OHCI_CTRL_IR) {
+		/* SMM owns the HC - request ownership */
+		writel(OHCI_OCR, &ohci->regs->cmdstatus);
+		info("USB HC TakeOver from SMM");
+		while (readl(&ohci->regs->control) & OHCI_CTRL_IR) {
+			mdelay(10);
+			if (--smm_timeout == 0) {
+				err("USB HC TakeOver failed!");
+				return -1;
+			}
+		}
+	}
+
+	/* Disable HC interrupts */
+	writel(OHCI_INTR_MIE, &ohci->regs->intrdisable);
+
+	dbg("USB HC reset_hc usb-%s: ctrl = 0x%X ;",
+	    ohci->slot_name, readl(&ohci->regs->control));
+
+	/* Reset USB (needed by some controllers) */
+	writel(0, &ohci->regs->control);
+
+	/* HC Reset requires max 10 us delay */
+	writel(OHCI_HCR, &ohci->regs->cmdstatus);
+	while ((readl(&ohci->regs->cmdstatus) & OHCI_HCR) != 0) {
+		if (--timeout == 0) {
+			err("USB HC reset timed out!");
+			return -1;
+		}
+		udelay(1);
+	}
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* Start an OHCI controller, set the BUS operational
+ * enable interrupts
+ * connect the virtual root hub */
+
+static int hc_start(struct ohci *ohci)
+{
+	__u32 mask;
+	unsigned int fminterval;
+
+	ohci->disabled = 1;
+
+	/* Tell the controller where the control and bulk lists are
+	 * The lists are empty now. */
+
+	writel(0, &ohci->regs->ed_controlhead);
+	writel(0, &ohci->regs->ed_bulkhead);
+
+	/* a reset clears this */
+	writel((__u32) ohci->hcca, &ohci->regs->hcca);
+
+	fminterval = 0x2edf;
+	writel((fminterval * 9) / 10, &ohci->regs->periodicstart);
+	fminterval |= ((((fminterval - 210) * 6) / 7) << 16);
+	writel(fminterval, &ohci->regs->fminterval);
+	writel(0x628, &ohci->regs->lsthresh);
+
+	/* start controller operations */
+	ohci->hc_control = OHCI_CONTROL_INIT | OHCI_USB_OPER;
+	ohci->disabled = 0;
+	writel(ohci->hc_control, &ohci->regs->control);
+
+	/* disable all interrupts */
+	mask = (OHCI_INTR_SO | OHCI_INTR_WDH | OHCI_INTR_SF | OHCI_INTR_RD |
+		OHCI_INTR_UE | OHCI_INTR_FNO | OHCI_INTR_RHSC |
+		OHCI_INTR_OC | OHCI_INTR_MIE);
+	writel(mask, &ohci->regs->intrdisable);
+	/* clear all interrupts */
+	mask &= ~OHCI_INTR_MIE;
+	writel(mask, &ohci->regs->intrstatus);
+	/* Choose the interrupts we care about now  - but w/o MIE */
+	mask = OHCI_INTR_RHSC | OHCI_INTR_UE | OHCI_INTR_WDH | OHCI_INTR_SO;
+	writel(mask, &ohci->regs->intrenable);
+
+#ifdef	OHCI_USE_NPS
+	/* required for AMD-756 and some Mac platforms */
+	writel((roothub_a(ohci) | RH_A_NPS) & ~RH_A_PSM,
+	       &ohci->regs->roothub.a);
+	writel(RH_HS_LPSC, &ohci->regs->roothub.status);
+#endif /* OHCI_USE_NPS */
+
+	/* POTPGT delay is bits 24-31, in 2 ms units. */
+	mdelay((roothub_a(ohci) >> 23) & 0x1fe);
+
+	/* connect the virtual root hub */
+	ohci->rh.devnum = 0;
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* an interrupt happens */
+
+static int hc_interrupt(void)
+{
+	struct ohci *ohci = &gohci;
+	struct ohci_regs *regs = ohci->regs;
+	int ints;
+	int stat = -1;
+
+	if ((ohci->hcca->done_head != 0) &&
+	    !(m32_swap(ohci->hcca->done_head) & 0x01)) {
+
+		ints = OHCI_INTR_WDH;
+
+	} else {
+		ints = readl(&regs->intrstatus);
+		if (ints == ~(u32) 0) {
+			ohci->disabled++;
+			err("%s device removed!", ohci->slot_name);
+			return -1;
+		}
+		ints &= readl(&regs->intrenable);
+		if (ints == 0) {
+			dbg("hc_interrupt: returning..\n");
+			return 0xff;
+		}
+	}
+
+	/* dbg("Interrupt: %x frame: %x", ints,
+	    le16_to_cpu(ohci->hcca->frame_no)); */
+
+	if (ints & OHCI_INTR_RHSC) {
+		got_rhsc = 1;
+		stat = 0xff;
+	}
+
+	if (ints & OHCI_INTR_UE) {
+		ohci->disabled++;
+		err("OHCI Unrecoverable Error, controller usb-%s disabled",
+		    ohci->slot_name);
+		/* e.g. due to PCI Master/Target Abort */
+
+#ifdef	DEBUG
+		ohci_dump(ohci, 1);
+#else
+		mdelay(1);
+#endif
+		/* FIXME: be optimistic, hope that bug won't repeat often. */
+		/* Make some non-interrupt context restart the controller. */
+		/* Count and limit the retries though; either hardware or */
+		/* software errors can go forever... */
+		hc_reset(ohci);
+		return -1;
+	}
+
+	if (ints & OHCI_INTR_WDH) {
+		mdelay(1);
+
+		writel(OHCI_INTR_WDH, &regs->intrdisable);
+		stat = dl_done_list(&gohci, dl_reverse_done_list(&gohci));
+		writel(OHCI_INTR_WDH, &regs->intrenable);
+	}
+
+	if (ints & OHCI_INTR_SO) {
+		dbg("USB Schedule overrun\n");
+		writel(OHCI_INTR_SO, &regs->intrenable);
+		stat = -1;
+	}
+
+	/* FIXME:  this assumes SOF (1/ms) interrupts don't get lost... */
+	if (ints & OHCI_INTR_SF) {
+		unsigned int frame = m16_swap(ohci->hcca->frame_no) & 1;
+		mdelay(1);
+		writel(OHCI_INTR_SF, &regs->intrdisable);
+		if (ohci->ed_rm_list[frame] != NULL)
+			writel(OHCI_INTR_SF, &regs->intrenable);
+		stat = 0xff;
+	}
+
+	writel(ints, &regs->intrstatus);
+	return stat;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*-------------------------------------------------------------------------*/
+
+/* De-allocate all resources.. */
+
+static void hc_release_ohci(struct ohci *ohci)
+{
+	dbg("USB HC release ohci usb-%s", ohci->slot_name);
+
+	if (!ohci->disabled)
+		hc_reset(ohci);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * low level initalisation routine, called from usb.c
+ */
+static char ohci_inited = 0;
+
+int usb_lowlevel_init(int index, enum usb_init_type init, void **controller)
+{
+	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
+	struct s3c24x0_gpio *gpio = s3c24x0_get_base_gpio();
+
+	/*
+	 * Set the 48 MHz UPLL clocking. Values are taken from
+	 * "PLL value selection guide", 6-23, s3c2400_UM.pdf.
+	 */
+	clk_power->upllcon = ((40 << 12) + (1 << 4) + 2);
+	gpio->misccr |= 0x8;	/* 1 = use pads related USB for USB host */
+
+	/*
+	 * Enable USB host clock.
+	 */
+	clk_power->clkcon |= (1 << 4);
+
+	memset(&gohci, 0, sizeof(struct ohci));
+	memset(&urb_priv, 0, sizeof(struct urb_priv));
+
+	/* align the storage */
+	if ((__u32) &ghcca[0] & 0xff) {
+		err("HCCA not aligned!!");
+		return -1;
+	}
+	phcca = &ghcca[0];
+	info("aligned ghcca %p", phcca);
+	memset(&ohci_dev, 0, sizeof(struct ohci_device));
+	if ((__u32) &ohci_dev.ed[0] & 0x7) {
+		err("EDs not aligned!!");
+		return -1;
+	}
+	memset(gtd, 0, sizeof(struct td) * (NUM_TD + 1));
+	if ((__u32) gtd & 0x7) {
+		err("TDs not aligned!!");
+		return -1;
+	}
+	ptd = gtd;
+	gohci.hcca = phcca;
+	memset(phcca, 0, sizeof(struct ohci_hcca));
+
+	gohci.disabled = 1;
+	gohci.sleeping = 0;
+	gohci.irq = -1;
+	gohci.regs = (struct ohci_regs *)S3C24X0_USB_HOST_BASE;
+
+	gohci.flags = 0;
+	gohci.slot_name = "s3c2400";
+
+	if (hc_reset(&gohci) < 0) {
+		hc_release_ohci(&gohci);
+		/* Initialization failed */
+		clk_power->clkcon &= ~(1 << 4);
+		return -1;
+	}
+
+	/* FIXME this is a second HC reset; why?? */
+	gohci.hc_control = OHCI_USB_RESET;
+	writel(gohci.hc_control, &gohci.regs->control);
+	mdelay(10);
+
+	if (hc_start(&gohci) < 0) {
+		err("can't start usb-%s", gohci.slot_name);
+		hc_release_ohci(&gohci);
+		/* Initialization failed */
+		clk_power->clkcon &= ~(1 << 4);
+		return -1;
+	}
+#ifdef	DEBUG
+	ohci_dump(&gohci, 1);
+#else
+	mdelay(1);
+#endif
+	ohci_inited = 1;
+	urb_finished = 1;
+
+	return 0;
+}
+
+int usb_lowlevel_stop(int index)
+{
+	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
+
+	/* this gets called really early - before the controller has */
+	/* even been initialized! */
+	if (!ohci_inited)
+		return 0;
+	/* TODO release any interrupts, etc. */
+	/* call hc_release_ohci() here ? */
+	hc_reset(&gohci);
+	/* may not want to do this */
+	clk_power->clkcon &= ~(1 << 4);
+	return 0;
+}
+
+#endif /* defined(CONFIG_USB_OHCI) && defined(CONFIG_S3C24X0) */
+
+#if defined(CONFIG_USB_OHCI_NEW) && \
+    defined(CONFIG_SYS_USB_OHCI_CPU_INIT) && \
+    defined(CONFIG_S3C24X0)
+
+int usb_cpu_init(void)
+{
+	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
+	struct s3c24x0_gpio *gpio = s3c24x0_get_base_gpio();
+
+	/*
+	 * Set the 48 MHz UPLL clocking. Values are taken from
+	 * "PLL value selection guide", 6-23, s3c2400_UM.pdf.
+	 */
+	writel((40 << 12) + (1 << 4) + 2, &clk_power->upllcon);
+	/* 1 = use pads related USB for USB host */
+	writel(readl(&gpio->misccr) | 0x8, &gpio->misccr);
+
+	/*
+	 * Enable USB host clock.
+	 */
+	writel(readl(&clk_power->clkcon) | (1 << 4), &clk_power->clkcon);
+
+	return 0;
+}
+
+int usb_cpu_stop(void)
+{
+	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
+	/* may not want to do this */
+	writel(readl(&clk_power->clkcon) & ~(1 << 4), &clk_power->clkcon);
+	return 0;
+}
+
+int usb_cpu_init_fail(void)
+{
+	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
+	writel(readl(&clk_power->clkcon) & ~(1 << 4), &clk_power->clkcon);
+	return 0;
+}
+
+#endif /* defined(CONFIG_USB_OHCI_NEW) && \
+	   defined(CONFIG_SYS_USB_OHCI_CPU_INIT) && \
+	   defined(CONFIG_S3C24X0) */
diff -urN u-boot-2020.07/drivers/usb/host/ohci-s3c24xx.h u-boot_2020.07_100ask/drivers/usb/host/ohci-s3c24xx.h
--- u-boot-2020.07/drivers/usb/host/ohci-s3c24xx.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/drivers/usb/host/ohci-s3c24xx.h	2020-08-03 18:15:03.011104354 +0800
@@ -0,0 +1,409 @@
+/*
+ * URB OHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2001 David Brownell <dbrownell@users.sourceforge.net>
+ *
+ * usb-ohci.h
+ */
+
+
+static int cc_to_error[16] = {
+
+/* mapping of the OHCI CC status to error codes */
+	/* No  Error  */ 0,
+	/* CRC Error  */ USB_ST_CRC_ERR,
+	/* Bit Stuff  */ USB_ST_BIT_ERR,
+	/* Data Togg  */ USB_ST_CRC_ERR,
+	/* Stall      */ USB_ST_STALLED,
+	/* DevNotResp */ -1,
+	/* PIDCheck   */ USB_ST_BIT_ERR,
+	/* UnExpPID   */ USB_ST_BIT_ERR,
+	/* DataOver   */ USB_ST_BUF_ERR,
+	/* DataUnder  */ USB_ST_BUF_ERR,
+	/* reservd    */ -1,
+	/* reservd    */ -1,
+	/* BufferOver */ USB_ST_BUF_ERR,
+	/* BuffUnder  */ USB_ST_BUF_ERR,
+	/* Not Access */ -1,
+	/* Not Access */ -1
+};
+
+/* ED States */
+#define ED_NEW		0x00
+#define ED_UNLINK	0x01
+#define ED_OPER		0x02
+#define ED_DEL		0x04
+#define ED_URB_DEL	0x08
+
+/* usb_ohci_ed */
+struct ed {
+	__u32 hwINFO;
+	__u32 hwTailP;
+	__u32 hwHeadP;
+	__u32 hwNextED;
+
+	struct ed *ed_prev;
+	__u8 int_period;
+	__u8 int_branch;
+	__u8 int_load;
+	__u8 int_interval;
+	__u8 state;
+	__u8 type;
+	__u16 last_iso;
+	struct ed *ed_rm_list;
+
+	struct usb_device *usb_dev;
+	__u32 unused[3];
+} __attribute__ ((aligned(16)));
+
+/* TD info field */
+#define TD_CC			0xf0000000
+#define TD_CC_GET(td_p)		(((td_p) >> 28) & 0x0f)
+#define TD_CC_SET(td_p, cc) \
+	{(td_p) = ((td_p) & 0x0fffffff) | (((cc) & 0x0f) << 28)}
+#define TD_EC			0x0C000000
+#define TD_T			0x03000000
+#define TD_T_DATA0		0x02000000
+#define TD_T_DATA1		0x03000000
+#define TD_T_TOGGLE		0x00000000
+#define TD_R			0x00040000
+#define TD_DI			0x00E00000
+#define TD_DI_SET(X)		(((X) & 0x07)<< 21)
+#define TD_DP			0x00180000
+#define TD_DP_SETUP		0x00000000
+#define TD_DP_IN		0x00100000
+#define TD_DP_OUT		0x00080000
+
+#define TD_ISO			0x00010000
+#define TD_DEL			0x00020000
+
+/* CC Codes */
+#define TD_CC_NOERROR		0x00
+#define TD_CC_CRC		0x01
+#define TD_CC_BITSTUFFING	0x02
+#define TD_CC_DATATOGGLEM	0x03
+#define TD_CC_STALL		0x04
+#define TD_DEVNOTRESP		0x05
+#define TD_PIDCHECKFAIL	0x06
+#define TD_UNEXPECTEDPID	0x07
+#define TD_DATAOVERRUN		0x08
+#define TD_DATAUNDERRUN	0x09
+#define TD_BUFFEROVERRUN	0x0C
+#define TD_BUFFERUNDERRUN	0x0D
+#define TD_NOTACCESSED		0x0F
+
+
+#define MAXPSW 1
+
+struct td {
+	__u32 hwINFO;
+	__u32 hwCBP;		/* Current Buffer Pointer */
+	__u32 hwNextTD;		/* Next TD Pointer */
+	__u32 hwBE;		/* Memory Buffer End Pointer */
+
+	__u8 unused;
+	__u8 index;
+	struct ed *ed;
+	struct td *next_dl_td;
+	struct usb_device *usb_dev;
+	int transfer_len;
+	__u32 data;
+
+	__u32 unused2[2];
+} __attribute__ ((aligned(32)));
+
+#define OHCI_ED_SKIP	(1 << 14)
+
+/*
+ * The HCCA (Host Controller Communications Area) is a 256 byte
+ * structure defined in the OHCI spec. that the host controller is
+ * told the base address of.  It must be 256-byte aligned.
+ */
+
+#define NUM_INTS 32		/* part of the OHCI standard */
+struct ohci_hcca {
+	__u32 int_table[NUM_INTS];	/* Interrupt ED table */
+	__u16 frame_no;		/* current frame number */
+	__u16 pad1;		/* set to 0 on each frame_no change */
+	__u32 done_head;	/* info returned for an interrupt */
+	u8 reserved_for_hc[116];
+} __attribute__ ((aligned(256)));
+
+/*
+ * Maximum number of root hub ports.
+ */
+#define MAX_ROOT_PORTS	15	/* maximum OHCI root hub ports */
+
+/*
+ * This is the structure of the OHCI controller's memory mapped I/O
+ * region.  This is Memory Mapped I/O.	You must use the readl() and
+ * writel() macros defined in asm/io.h to access these!!
+ */
+struct ohci_regs {
+	/* control and status registers */
+	__u32 revision;
+	__u32 control;
+	__u32 cmdstatus;
+	__u32 intrstatus;
+	__u32 intrenable;
+	__u32 intrdisable;
+	/* memory pointers */
+	__u32 hcca;
+	__u32 ed_periodcurrent;
+	__u32 ed_controlhead;
+	__u32 ed_controlcurrent;
+	__u32 ed_bulkhead;
+	__u32 ed_bulkcurrent;
+	__u32 donehead;
+	/* frame counters */
+	__u32 fminterval;
+	__u32 fmremaining;
+	__u32 fmnumber;
+	__u32 periodicstart;
+	__u32 lsthresh;
+	/* Root hub ports */
+	struct ohci_roothub_regs {
+		__u32 a;
+		__u32 b;
+		__u32 status;
+		__u32 portstatus[MAX_ROOT_PORTS];
+	} roothub;
+} __attribute__ ((aligned(32)));
+
+/* OHCI CONTROL AND STATUS REGISTER MASKS */
+
+/*
+ * HcControl (control) register masks
+ */
+#define OHCI_CTRL_CBSR	(3 << 0)	/* control/bulk service ratio */
+#define OHCI_CTRL_PLE	(1 << 2)	/* periodic list enable */
+#define OHCI_CTRL_IE	(1 << 3)	/* isochronous enable */
+#define OHCI_CTRL_CLE	(1 << 4)	/* control list enable */
+#define OHCI_CTRL_BLE	(1 << 5)	/* bulk list enable */
+#define OHCI_CTRL_HCFS	(3 << 6)	/* host controller functional state */
+#define OHCI_CTRL_IR	(1 << 8)	/* interrupt routing */
+#define OHCI_CTRL_RWC	(1 << 9)	/* remote wakeup connected */
+#define OHCI_CTRL_RWE	(1 << 10)	/* remote wakeup enable */
+
+/* pre-shifted values for HCFS */
+#	define OHCI_USB_RESET	(0 << 6)
+#	define OHCI_USB_RESUME	(1 << 6)
+#	define OHCI_USB_OPER	(2 << 6)
+#	define OHCI_USB_SUSPEND	(3 << 6)
+
+/*
+ * HcCommandStatus (cmdstatus) register masks
+ */
+#define OHCI_HCR	(1 << 0)	/* host controller reset */
+#define OHCI_CLF	(1 << 1)	/* control list filled */
+#define OHCI_BLF	(1 << 2)	/* bulk list filled */
+#define OHCI_OCR	(1 << 3)	/* ownership change request */
+#define OHCI_SOC	(3 << 16)	/* scheduling overrun count */
+
+/*
+ * masks used with interrupt registers:
+ * HcInterruptStatus (intrstatus)
+ * HcInterruptEnable (intrenable)
+ * HcInterruptDisable (intrdisable)
+ */
+#define OHCI_INTR_SO	(1 << 0)	/* scheduling overrun */
+#define OHCI_INTR_WDH	(1 << 1)	/* writeback of done_head */
+#define OHCI_INTR_SF	(1 << 2)	/* start frame */
+#define OHCI_INTR_RD	(1 << 3)	/* resume detect */
+#define OHCI_INTR_UE	(1 << 4)	/* unrecoverable error */
+#define OHCI_INTR_FNO	(1 << 5)	/* frame number overflow */
+#define OHCI_INTR_RHSC	(1 << 6)	/* root hub status change */
+#define OHCI_INTR_OC	(1 << 30)	/* ownership change */
+#define OHCI_INTR_MIE	(1 << 31)	/* master interrupt enable */
+
+/* Virtual Root HUB */
+struct virt_root_hub {
+	int devnum;		/* Address of Root Hub endpoint */
+	void *dev;		/* was urb */
+	void *int_addr;
+	int send;
+	int interval;
+};
+
+/* USB HUB CONSTANTS (not OHCI-specific; see hub.h) */
+
+/* destination of request */
+#define RH_INTERFACE		0x01
+#define RH_ENDPOINT		0x02
+#define RH_OTHER		0x03
+
+#define RH_CLASS		0x20
+#define RH_VENDOR		0x40
+
+/* Requests: bRequest << 8 | bmRequestType */
+#define RH_GET_STATUS		0x0080
+#define RH_CLEAR_FEATURE	0x0100
+#define RH_SET_FEATURE		0x0300
+#define RH_SET_ADDRESS		0x0500
+#define RH_GET_DESCRIPTOR	0x0680
+#define RH_SET_DESCRIPTOR	0x0700
+#define RH_GET_CONFIGURATION	0x0880
+#define RH_SET_CONFIGURATION	0x0900
+#define RH_GET_STATE		0x0280
+#define RH_GET_INTERFACE	0x0A80
+#define RH_SET_INTERFACE	0x0B00
+#define RH_SYNC_FRAME		0x0C80
+/* Our Vendor Specific Request */
+#define RH_SET_EP		0x2000
+
+
+/* Hub port features */
+#define RH_PORT_CONNECTION	0x00
+#define RH_PORT_ENABLE		0x01
+#define RH_PORT_SUSPEND		0x02
+#define RH_PORT_OVER_CURRENT	0x03
+#define RH_PORT_RESET		0x04
+#define RH_PORT_POWER		0x08
+#define RH_PORT_LOW_SPEED	0x09
+
+#define RH_C_PORT_CONNECTION	0x10
+#define RH_C_PORT_ENABLE	0x11
+#define RH_C_PORT_SUSPEND	0x12
+#define RH_C_PORT_OVER_CURRENT	0x13
+#define RH_C_PORT_RESET		0x14
+
+/* Hub features */
+#define RH_C_HUB_LOCAL_POWER	0x00
+#define RH_C_HUB_OVER_CURRENT	0x01
+
+#define RH_DEVICE_REMOTE_WAKEUP 0x00
+#define RH_ENDPOINT_STALL	0x01
+
+#define RH_ACK			0x01
+#define RH_REQ_ERR		-1
+#define RH_NACK			0x00
+
+
+/* OHCI ROOT HUB REGISTER MASKS */
+
+/* roothub.portstatus [i] bits */
+#define RH_PS_CCS		0x00000001 /* current connect status */
+#define RH_PS_PES		0x00000002 /* port enable status */
+#define RH_PS_PSS		0x00000004 /* port suspend status */
+#define RH_PS_POCI		0x00000008 /* port over current indicator */
+#define RH_PS_PRS		0x00000010 /* port reset status */
+#define RH_PS_PPS		0x00000100 /* port power status */
+#define RH_PS_LSDA		0x00000200 /* low speed device attached */
+#define RH_PS_CSC		0x00010000 /* connect status change */
+#define RH_PS_PESC		0x00020000 /* port enable status change */
+#define RH_PS_PSSC		0x00040000 /* port suspend status change */
+#define RH_PS_OCIC		0x00080000 /* over current indicator change */
+#define RH_PS_PRSC		0x00100000 /* port reset status change */
+
+/* roothub.status bits */
+#define RH_HS_LPS		0x00000001 /* local power status */
+#define RH_HS_OCI		0x00000002 /* over current indicator */
+#define RH_HS_DRWE		0x00008000 /* device remote wakeup enable */
+#define RH_HS_LPSC		0x00010000 /* local power status change */
+#define RH_HS_OCIC		0x00020000 /* over current indicator change */
+#define RH_HS_CRWE		0x80000000 /* clear remote wakeup enable */
+
+/* roothub.b masks */
+#define RH_B_DR			0x0000ffff /* device removable flags */
+#define RH_B_PPCM		0xffff0000 /* port power control mask */
+
+/* roothub.a masks */
+#define	RH_A_NDP		(0xff << 0)  /* number of downstream ports */
+#define	RH_A_PSM		(1 << 8)     /* power switching mode */
+#define	RH_A_NPS		(1 << 9)     /* no power switching */
+#define	RH_A_DT			(1 << 10)    /* device type (mbz) */
+#define	RH_A_OCPM		(1 << 11)    /* over current protection mode */
+#define	RH_A_NOCP		(1 << 12)    /* no over current protection */
+#define	RH_A_POTPGT		(0xff << 24) /* power on to power good time */
+
+/* urb */
+#define N_URB_TD 48
+struct urb_priv {
+	struct ed *ed;
+	__u16 length;		/* number of tds associated with this request */
+	__u16 td_cnt;		/* number of tds already serviced */
+	int state;
+	unsigned long pipe;
+	int actual_length;
+	struct td *td[N_URB_TD];	/* list pointer to all corresponding TDs
+					   associated with this request */
+};
+#define URB_DEL 1
+
+/*
+ * This is the full ohci controller description
+ *
+ * Note how the "proper" USB information is just
+ * a subset of what the full implementation needs. (Linus)
+ */
+
+
+struct ohci {
+	struct ohci_hcca *hcca;	/* hcca */
+	/*dma_addr_t hcca_dma; */
+
+	int irq;
+	int disabled;		/* e.g. got a UE, we're hung */
+	int sleeping;
+	unsigned long flags;	/* for HC bugs */
+
+	struct ohci_regs *regs;	/* OHCI controller's memory */
+
+	struct ed *ed_rm_list[2];  /* lists of all endpoints to be removed */
+	struct ed *ed_bulktail;    /* last endpoint of bulk list */
+	struct ed *ed_controltail; /* last endpoint of control list */
+	int intrstatus;
+	__u32 hc_control;	/* copy of the hc control reg */
+	struct usb_device *dev[32];
+	struct virt_root_hub rh;
+
+	const char *slot_name;
+};
+
+#define NUM_EDS 8		/* num of preallocated endpoint descriptors */
+
+struct ohci_device {
+	struct ed ed[NUM_EDS];
+	int ed_cnt;
+};
+
+/* hcd */
+/* endpoint */
+static int ep_link(struct ohci *ohci, struct ed *ed);
+static int ep_unlink(struct ohci *ohci, struct ed *ed);
+static struct ed *ep_add_ed(struct usb_device *usb_dev, unsigned long pipe);
+
+/*-------------------------------------------------------------------------*/
+
+/* we need more TDs than EDs */
+#define NUM_TD 64
+
+/* +1 so we can align the storage */
+struct td gtd[NUM_TD + 1];
+
+/* pointers to aligned storage */
+struct td *ptd;
+
+/* TDs ... */
+static inline struct td *td_alloc(struct usb_device *usb_dev)
+{
+	int i;
+	struct td *td;
+
+	td = NULL;
+	for (i = 0; i < NUM_TD; i++) {
+		if (ptd[i].usb_dev == NULL) {
+			td = &ptd[i];
+			td->usb_dev = usb_dev;
+			break;
+		}
+	}
+
+	return td;
+}
+
+static inline void ed_free(struct ed *ed)
+{
+	ed->usb_dev = NULL;
+}
diff -urN u-boot-2020.07/include/configs/jz2440.h u-boot_2020.07_100ask/include/configs/jz2440.h
--- u-boot-2020.07/include/configs/jz2440.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/include/configs/jz2440.h	2020-08-03 18:15:03.023104465 +0800
@@ -0,0 +1,225 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Gary Jennejohn <garyj@denx.de>
+ * David Mueller <d.mueller@elsoft.ch>
+ *
+ * Configuation settings for the SAMSUNG SMDK2410 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*DaQui modified*/
+#define CONFIG_SPL
+#define CONFIG_SPL_STACK	(0x30000000 + 0x1000 - 176)
+#define CONFIG_SPL_TEXT_BASE 0x0
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_S3C24X0		/* This is a SAMSUNG S3C24x0-type SoC */
+#define CONFIG_S3C2440		/* specifically a SAMSUNG S3C2440 SoC */
+/*#define CONFIG_SMDK2440		 on a SAMSUNG SMDK2440 Board */
+#define CONFIG_JZ2440		/* on a 100ask JZ2440 Board */
+
+
+#if 0
+#define CONFIG_SYS_TEXT_BASE	0x33F00000
+#endif
+
+#define CONFIG_SYS_ARM_CACHE_WRITETHROUGH
+
+/* input clock of PLL (the SMDK2410 has 12MHz input clock) */
+#define CONFIG_SYS_CLK_FREQ	12000000
+
+#define CONFIG_CMDLINE_TAG	/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+
+/*
+ * Hardware drivers  
+ */
+/*DaQui modified*/
+#define CONFIG_DRIVER_DM9000
+#define CONFIG_DM9000_BASE              0x20000000
+#define DM9000_IO                       CONFIG_DM9000_BASE
+#define DM9000_DATA                     (CONFIG_DM9000_BASE + 4)
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_S3C24X0_SERIAL
+#define CONFIG_SERIAL1		1	/* we use SERIAL 1 on SMDK2440 */
+
+/************************************************************
+ * USB support (currently only works with D-cache off)
+ ************************************************************/
+
+#define CONFIG_USB_OHCI
+#define CONFIG_USB_OHCI_S3C24XX
+#if 0 /*DaQui modified*/
+#define CONFIG_DOS_PARTITION
+#endif
+
+/************************************************************
+ * RTC
+ ************************************************************/
+#define CONFIG_RTC_S3C24X0
+#define CONFIG_BAUDRATE		115200
+
+/*
+ * BOOTP options
+ */
+
+#if 0  /*DaQui modified*/
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#endif
+
+/*DaQui modified*/
+#define CONFIG_CMD_NAND_YAFFS
+#if 0
+#define CONFIG_BOOTARGS "console=ttySAC0 root=/dev/mtdblock4"
+#define CONFIG_BOOTCOMMAND "nand read 30000000 kernel;bootm 30000000"
+#endif
+/*
+ * Command line configuration.
+ */
+ #if 0  
+#define CONFIG_CMD_BSP
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_REGINFO
+#define CONFIG_CMDLINE_EDITING
+#endif
+
+/* autoboot */
+#define CONFIG_BOOT_RETRY_TIME	-1
+#define CONFIG_RESET_TO_RETRY
+
+#define CONFIG_NETMASK		255.255.255.0
+#define CONFIG_IPADDR		192.168.1.17
+#define CONFIG_SERVERIP		192.168.1.11
+#define CONFIG_ETHADDR		60:F2:EF:03:03:1A
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200	/* speed to run kgdb serial port */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#if 0
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#endif
+
+#define CONFIG_SYS_CBSIZE	256
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE	(CONFIG_SYS_CBSIZE + \
+				sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS	16
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MEMTEST_START	0x30000000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x33F00000	/* 63 MB in DRAM */
+
+#define CONFIG_SYS_LOAD_ADDR		0x30800000
+
+/* support additional compression methods */
+#if 0  /*DaQui modified*/
+#define CONFIG_BZIP2
+#define CONFIG_LZO
+#define CONFIG_LZMA
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#if 0
+#define CONFIG_NR_DRAM_BANKS	1          /* we have 1 bank of DRAM */
+#endif 
+#define PHYS_SDRAM_1		0x30000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #0 */
+
+#define CONFIG_SYS_FLASH_BASE	PHYS_FLASH_1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CONFIG_FLASH_CFI_LEGACY
+#define CONFIG_SYS_FLASH_LEGACY_2Mx8
+#define CONFIG_FLASH_SHOW_PROGRESS	45
+
+/*DaQui modified*/
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_FLASH_BANKS_LIST     { CONFIG_SYS_FLASH_BASE }
+#define CONFIG_SYS_MAX_FLASH_SECT	(64)
+
+/*DaQui modified*/
+#if 0
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_OFFSET		0x60000
+#define CONFIG_ENV_SIZE			0x20000
+#define CONFIG_ENV_RANGE       CONFIG_ENV_SIZE
+#endif
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Size of malloc() pool
+ * BZIP2 / LZO / LZMA need a lot of RAM
+ */
+#define CONFIG_SYS_MALLOC_LEN	(4 * 1024 * 1024)
+#define CONFIG_SYS_MONITOR_LEN	(448 * 1024)
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_FLASH_BASE
+
+/*
+ * NAND configuration  
+ */
+ /*DaQui modified*/
+#define CONFIG_NAND_S3C2440
+/* #define CONFIG_SYS_S3C2410_NAND_HWECC */ /* DaQui modified */
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x4E000000
+
+/*
+ * File system  
+ */
+ /*DaQui modified*/
+#if 0
+#define CONFIG_RBTREE
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_MTD_DEVICE
+/* #define CONFIG_MTD_PARTITIONS */
+#define MTDIDS_DEFAULT          "nand0=jz2440-0"  
+#define MTDPARTS_DEFAULT        "mtdparts=jz2440-0:128k@0(spl),"        \
+                                                "256k(bootloader),"     \
+                                                "128k(params),"         \
+                                                "2m(kernel),"   \
+                                                "-(root)"       
+
+#endif
+
+#if 0  /*DaQui modified*/
+#define CONFIG_CMD_UBIFS
+#define CONFIG_YAFFS2
+#endif
+
+/* additions for new relocation code, must be added to all boards */
+#define CONFIG_SYS_SDRAM_BASE	PHYS_SDRAM_1
+#define CONFIG_SYS_INIT_SP_ADDR	(CONFIG_SYS_SDRAM_BASE + 0x1000 - \
+				GENERATED_GBL_DATA_SIZE)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+
+#endif /* __CONFIG_H */
diff -urN u-boot-2020.07/include/nand.h u-boot_2020.07_100ask/include/nand.h
--- u-boot-2020.07/include/nand.h	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/include/nand.h	2020-08-03 18:15:03.055104756 +0800
@@ -102,6 +102,9 @@
 
 #define WITH_DROP_FFS	(1 << 0) /* drop trailing all-0xff pages */
 #define WITH_WR_VERIFY	(1 << 1) /* verify data was written correctly */
+#define WITH_YAFFS_OOB  (1 << 2) /* whether write with yaffs format. This flag
+                                  * is a 'mode' meaning it cannot be mixed with
+                                  * other flags */
 
 int nand_write_skip_bad(struct mtd_info *mtd, loff_t offset, size_t *length,
 			size_t *actual, loff_t lim, u_char *buffer, int flags);
diff -urN u-boot-2020.07/Makefile u-boot_2020.07_100ask/Makefile
--- u-boot-2020.07/Makefile	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/Makefile	2020-08-03 18:15:02.923103554 +0800
@@ -1,10 +1,11 @@
-# SPDX-License-Identifier: GPL-2.0+
-
+# SPDX-License-Identifier: GPL-2.0+ 
 VERSION = 2020
 PATCHLEVEL = 07
 SUBLEVEL =
 EXTRAVERSION =
 NAME =
+ARCH = arch
+CROSS_COMPILE = arm-jz2440-linux-gnueabi-
 
 # *DOCUMENTATION*
 # To see a list of typical targets execute "make help"
@@ -289,6 +290,7 @@
 # have older compilers as their default, so we make it explicit for
 # these that our host tools are GNU11 (i.e. C11 w/ GNU extensions).
 CSTD_FLAG := -std=gnu11
+#CSTD_FLAG := -std=gnu99
 ifeq ($(HOSTOS),linux)
 KBUILD_HOSTCFLAGS += $(CSTD_FLAG)
 endif
@@ -854,7 +856,7 @@
 BOARD_SIZE_CHECK =
 endif
 
-ifneq ($(CONFIG_SPL_SIZE_LIMIT),0)
+ifneq ($(CONFIG_SPL_SIZE_LIMIT),)
 SPL_SIZE_CHECK = @$(call size_check,$@,$$(tools/spl_size_limit))
 else
 SPL_SIZE_CHECK =
diff -urN u-boot-2020.07/scripts/config_whitelist.txt u-boot_2020.07_100ask/scripts/config_whitelist.txt
--- u-boot-2020.07/scripts/config_whitelist.txt	2020-07-07 03:22:53.000000000 +0800
+++ u-boot_2020.07_100ask/scripts/config_whitelist.txt	2020-08-03 18:15:03.079104975 +0800
@@ -196,6 +196,7 @@
 CONFIG_CM922T_XA10
 CONFIG_CMDLINE_PS_SUPPORT
 CONFIG_CMDLINE_TAG
+CONFIG_CMD_NAND_YAFFS
 CONFIG_CM_INIT
 CONFIG_CM_MULTIPLE_SSRAM
 CONFIG_CM_REMAP
@@ -887,6 +888,7 @@
 CONFIG_JFFS2_SUMMARY
 CONFIG_JRSTARTR_JR0
 CONFIG_JTAG_CONSOLE
+CONFIG_JZ2440
 CONFIG_KCLK_DIS
 CONFIG_KEEP_SERVERADDR
 CONFIG_KERNEL_OFFSET
@@ -1177,6 +1179,7 @@
 CONFIG_NAND_MODE_REG
 CONFIG_NAND_OMAP_ECCSCHEME
 CONFIG_NAND_OMAP_GPMC_WSCFG
+CONFIG_NAND_S3C2440
 CONFIG_NAND_SECBOOT
 CONFIG_NAND_SPL
 CONFIG_NAND_U_BOOT
@@ -1456,11 +1459,15 @@
 CONFIG_RTC_MXS
 CONFIG_RTC_PCF8563
 CONFIG_RTC_PT7C4338
+CONFIG_RTC_S3C24X0
 CONFIG_RUN_FROM_DDR0
 CONFIG_RUN_FROM_DDR1
 CONFIG_RUN_FROM_IRAM_ONLY
 CONFIG_RX_DESCR_NUM
 CONFIG_S32V234
+CONFIG_S3C2440
+CONFIG_S3C24X0
+CONFIG_S3C24X0_SERIAL
 CONFIG_S5P
 CONFIG_S5PC100
 CONFIG_S5PC110
@@ -1495,6 +1502,7 @@
 CONFIG_SECURITY
 CONFIG_SEC_DEQ_TIMEOUT
 CONFIG_SEC_FW_SIZE
+CONFIG_SERIAL1
 CONFIG_SERIAL_BOOT
 CONFIG_SERIAL_FLASH
 CONFIG_SERIAL_HW_FLOW_CONTROL
@@ -2296,6 +2304,7 @@
 CONFIG_SYS_FLASH_LEGACY_256Kx8
 CONFIG_SYS_FLASH_LEGACY_512Kx16
 CONFIG_SYS_FLASH_LEGACY_512Kx8
+CONFIG_SYS_FLASH_LEGACY_2Mx8
 CONFIG_SYS_FLASH_LOCK_TOUT
 CONFIG_SYS_FLASH_OR_PRELIM
 CONFIG_SYS_FLASH_PARMSECT_SZ
@@ -4145,9 +4154,11 @@
 CONFIG_USB_MAX_CONTROLLER_COUNT
 CONFIG_USB_MUSB_TIMEOUT
 CONFIG_USB_MUSB_TUSB6010
+CONFIG_USB_OHCI
 CONFIG_USB_OHCI_EP93XX
 CONFIG_USB_OHCI_LPC32XX
 CONFIG_USB_OHCI_NEW
+CONFIG_USB_OHCI_S3C24XX
 CONFIG_USB_OTG
 CONFIG_USB_OTG_BLACKLIST_HUB
 CONFIG_USB_PHY_TYPE
diff -urN u-boot-2020.07/tools/env/embedded.c u-boot_2020.07_100ask/tools/env/embedded.c
--- u-boot-2020.07/tools/env/embedded.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot_2020.07_100ask/tools/env/embedded.c	2020-08-03 18:15:03.111105266 +0800
@@ -0,0 +1 @@
+#include <../env/embedded.c>
